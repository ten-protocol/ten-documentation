"use strict";(self.webpackChunkten_docs=self.webpackChunkten_docs||[]).push([[267],{2700:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>l});const a=JSON.parse('{"id":"smart-contract-features/native-commit-reveal","title":"Native commit-reveal","description":"Every on-chain game developer knows that moves that rely on entropy must be executed in two steps.","source":"@site/docs/3-smart-contract-features/3-native-commit-reveal.md","sourceDirName":"3-smart-contract-features","slug":"/smart-contract-features/native-commit-reveal","permalink":"/docs/smart-contract-features/native-commit-reveal","draft":false,"unlisted":false,"editUrl":"https://github.com/ten-protocol/ten-documentation/blob/main/docs/3-smart-contract-features/3-native-commit-reveal.md","tags":[],"version":"current","sidebarPosition":3,"frontMatter":{"sidebar_position":3},"sidebar":"tutorialSidebar","previous":{"title":"Native secure entropy","permalink":"/docs/smart-contract-features/native-entropy"},"next":{"title":"Precise transaction timestamp","permalink":"/docs/smart-contract-features/transaction-timestamp"}}');var o=n(4848),s=n(8453);const i={sidebar_position:3},r="Native commit-reveal",c={},l=[{value:"The on-block-end callback",id:"the-on-block-end-callback",level:2},{value:"How it works",id:"how-it-works",level:3},{value:"Example",id:"example",level:3}];function d(e){const t={a:"a",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.header,{children:(0,o.jsx)(t.h1,{id:"native-commit-reveal",children:"Native commit-reveal"})}),"\n",(0,o.jsx)(t.p,{children:"Every on-chain game developer knows that moves that rely on entropy must be executed in two steps."}),"\n",(0,o.jsxs)(t.p,{children:["Imagine you implement an on-chain coin flip game. The player pays 0.1ETH to choose ",(0,o.jsx)(t.code,{children:"Heads"})," or ",(0,o.jsx)(t.code,{children:"Tails"}),".\nIf they win, they receive 0.2ETH, otherwise they lose the 0.1ETH.\nEven if randomness is unpredictable, this simple game can be exploited in several ways:"]}),"\n",(0,o.jsxs)(t.ul,{children:["\n",(0,o.jsx)(t.li,{children:"The attacker can create a \u201cproxy\u201d smart contract to play on their behalf. Using a similar mechanism to flash loans in DeFi: the proxy is programmed to make multiple actions and only \u201ccommit\u201d if it can obtain a profit. In our case, if the coin flip is losing, the proxy can just revert. The only cost will be the gas burned."}),"\n",(0,o.jsx)(t.li,{children:"Transactions consume gas, and the gas cost can inadvertently reveal information. For instance, if a winning move is more computationally intensive than a losing one, players could deduce optimal moves by estimating gas costs for various actions."}),"\n"]}),"\n",(0,o.jsx)(t.p,{children:"The typical solution is to use an ad-hoc commit-reveal scheme. The smart contract ensures that the player commits to a move, and only afterwards reveals it to the chain.\nThis way, the player can't change their mind after seeing the result."}),"\n",(0,o.jsx)(t.p,{children:"This ad-hoc solution introduces extra complexity, latency and cost."}),"\n",(0,o.jsx)(t.h2,{id:"the-on-block-end-callback",children:"The on-block-end callback"}),"\n",(0,o.jsx)(t.p,{children:'The best solution is to decouple the move from the execution without increasing the latency or the cost.\nThis way, the side-channel attacks are no longer possible because the move is not executed immediately.\nTo avoid increasing the latency, the move must be executed in the same block as the "commit" transaction.'}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.strong,{children:"The TEN platform provides a way to register a callback to be executed at the end of the current block."})}),"\n",(0,o.jsx)(t.h3,{id:"how-it-works",children:"How it works"}),"\n",(0,o.jsxs)(t.p,{children:['TEN provides a "System Contract" (a contract deployed and known by the platform.)\nYou can get the address of the system contract for our testnet ',(0,o.jsx)(t.a,{href:"https://sepolia.tenscan.io/resources/verified-data",children:"here"}),' - "Ten System Contract".']}),"\n",(0,o.jsxs)(t.p,{children:["The interface for registering the callback is: ",(0,o.jsx)(t.a,{href:"https://github.com/ten-protocol/go-ten/blob/main/contracts/src/system/interfaces/IPublicCallbacks.sol",children:"IPublicCallbacks"}),"."]}),"\n",(0,o.jsx)(t.h3,{id:"example",children:"Example"}),"\n",(0,o.jsx)(t.p,{children:"See below a secure implementation of the coin flip game using the callback:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// this interface is known by the TEN system contract\ninterface IPublicCallbacks {\n    function register(bytes calldata callback) external payable returns (uint256);\n}\n\ncontract CoinFlip {\n    // Event to emit the result of the coin flip\n    event CoinFlipResult(address indexed player, bool didWin, uint256 randomNumber);\n\n    private IPublicCallbacks tenCallbacks;\n    mapping(uint256 callbackId => address player) public callbackToPlayer;\n    mapping(address player => uint256 refundAmount) public playerToRefundAmount;\n\n    modifier onlyTenSystemCall() { \n        require(msg.sender == address(tenCallbacks));\n        _;\n    }\n\n    // you have to pass in the address of the system contract\n    constructor(address _tenCallbacksAddress) {\n        tenCallbacks = TenCallbacks(_tenCallbacksAddress);\n    }\n\n    // Function to initiate a coin flip. \n    // Notice how it doesn\'t execute the coin flip directly, but instead registers a callback.\n    function flipCoin(bool isHeads) external payable {\n        // Assume doFlipCoin costs 50_000 gas;\n        // We deduct a predetermined amount from the bet to pay for delayed execution.\n        uint256 etherGasForCoinFlip = 50_000*block.basefee;\n        require(msg.value > etherGasForCoinFlip, "Insufficent gas");\n\n        // Encode the function we want to be called by the TEN system contract.\n        bytes memory callbackTargetInfo = abi.encodeWithSelector(this.doFlipCoin.selector, msg.sender, msg.value - etherGasForCoinFlip, isHeads);\n\n        // Commit the move\n        tenCallbacks.register{value: etherGasForCoinFlip}(callbackTargetInfo);\n    }\n\n    // Function to simulate a coin flip - notice that this must only be callable by the TEN system contract.\n    // This function is called by the TEN platform as a synthetic transaction in the same block as the user transaction.\n    function doFlipCoin(address bettor, uint256 stake, bool wantsHeads) external onlyTenSystemCall {\n        // Assume getRandomNumber() is a function that returns a random number\n        uint256 randomNumber = getRandomNumber();\n\n        // Simulate a coin flip: 0 for tails, 1 for heads\n        bool isHeads = (randomNumber % 2) == 1;\n\n        if (wantsHeads == isHeads) {\n            //pay out to winner\n            (bool success, ) = payable(bettor).call{value: stake*2}("");\n            require(success, "Payment failed.");\n        }\n        // Emit the result of the coin flip\n        emit CoinFlipResult(msg.sender, isHeads, randomNumber);\n    }\n\n    function getRandomNumber() internal view returns (uint256) {\n        // see native entropy\n    }\n\n}\n'})}),"\n",(0,o.jsx)(t.p,{children:'Notice how we split the logic in two. The first part is the "commit" part, which is executed by the user.\nThe second part is the "reveal" part, which is executed only by the TEN platform.'}),"\n",(0,o.jsx)(t.p,{children:(0,o.jsx)(t.em,{children:"Note that you have to enforce the second function to be called only by the TEN system contract."})})]})}function m(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(d,{...e})}):d(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>r});var a=n(6540);const o={},s=a.createContext(o);function i(e){const t=a.useContext(s);return a.useMemo(function(){return"function"==typeof e?e(t):{...t,...e}},[t,e])}function r(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:i(e.components),a.createElement(s.Provider,{value:t},e.children)}}}]);