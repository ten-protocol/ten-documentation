"use strict";(self.webpackChunkten_docs=self.webpackChunkten_docs||[]).push([[6613],{8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>d});var s=t(6540);const a={},r=s.createContext(a);function o(e){const n=s.useContext(r);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),s.createElement(r.Provider,{value:n},e.children)}},9497:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>i,contentTitle:()=>d,default:()=>c,frontMatter:()=>o,metadata:()=>s,toc:()=>l});const s=JSON.parse('{"id":"standards-primitives/fungible-tokens","title":"Fungible Tokens","description":"ERC-20 on TEN","source":"@site/docs/standards-primitives/fungible-tokens.md","sourceDirName":"standards-primitives","slug":"/standards-primitives/fungible-tokens","permalink":"/docs/standards-primitives/fungible-tokens","draft":false,"unlisted":false,"editUrl":"https://github.com/ten-protocol/ten-documentation/blob/main/docs/standards-primitives/fungible-tokens.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Standards & Primitives","permalink":"/docs/category/standards--primitives"},"next":{"title":"Random Numbers","permalink":"/docs/standards-primitives/random-numbers"}}');var a=t(4848),r=t(8453);const o={sidebar_position:1},d="Fungible Tokens",i={},l=[{value:"ERC-20 on TEN",id:"erc-20-on-ten",level:2},{value:"Methods:",id:"methods",level:3},{value:"Events:",id:"events",level:3},{value:"Examples",id:"examples",level:2},{value:"Further Reading",id:"further-reading",level:2}];function u(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",p:"p",pre:"pre",ul:"ul",...(0,r.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"fungible-tokens",children:"Fungible Tokens"})}),"\n",(0,a.jsx)(n.h2,{id:"erc-20-on-ten",children:"ERC-20 on TEN"}),"\n",(0,a.jsx)(n.p,{children:"The ERC-20 standard, while originally proposed for Ethereum, is also applicable to TEN's Layer 2. It provides an API for tokens within Smart Contracts and offers functionalities to:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Transfer tokens between accounts on TEN"}),"\n",(0,a.jsx)(n.li,{children:"Retrieve the current token balance of an account on TEN"}),"\n",(0,a.jsx)(n.li,{children:"Determine the total supply of the token on the TEN network"}),"\n",(0,a.jsx)(n.li,{children:"Approve third-party accounts to spend a specific amount of tokens on TEN"}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"A Smart Contract on TEN that implements the following methods and events adheres to the ERC-20 standard:"}),"\n",(0,a.jsx)(n.h3,{id:"methods",children:"Methods:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"name()"}),": Returns the name of the token."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"symbol()"}),": Returns the symbol of the token."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"decimals()"}),": Returns the number of decimals the token uses."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"totalSupply()"}),": Returns the total token supply."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"balanceOf(address _owner)"}),": Returns the token balance of the specified address."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"transfer(address _to, uint256 _value)"}),": Transfers tokens to a specified address."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"transferFrom(address _from, address _to, uint256 _value)"}),": Transfers tokens from one address to another."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"approve(address _spender, uint256 _value)"}),": Approves a third-party account to spend a specified amount of tokens."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"allowance(address _owner, address _spender)"}),": Returns the amount of tokens approved by an owner for a spender."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"events",children:"Events:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Transfer(address indexed _from, address indexed _to, uint256 _value)"}),": Triggered when tokens are transferred."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"Approval(address indexed _owner, address indexed _spender, uint256 _value)"}),": Triggered when ",(0,a.jsx)(n.code,{children:"approve"})," function is called."]}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"examples",children:"Examples"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'pragma solidity ^0.4.24;\n\nimport "./IERC20.sol";\nimport "../../math/SafeMath.sol";\n\n/**\n * @title Standard ERC20 token\n *\n * @dev Implementation of the basic standard token.\n * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md\n * Originally based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol\n */\ncontract ERC20 is IERC20 {\n  using SafeMath for uint256;\n\n  mapping (address => uint256) private _balances;\n\n  mapping (address => mapping (address => uint256)) private _allowed;\n\n  uint256 private _totalSupply;\n\n  /**\n  * @dev Total number of tokens in existence\n  */\n  function totalSupply() public view returns (uint256) {\n    return _totalSupply;\n  }\n\n  /**\n  * @dev Gets the balance of the specified address.\n  * @param owner The address to query the balance of.\n  * @return An uint256 representing the amount owned by the passed address.\n  */\n  function balanceOf(address owner) public view returns (uint256) {\n    return _balances[owner];\n  }\n\n  /**\n   * @dev Function to check the amount of tokens that an owner allowed to a spender.\n   * @param owner address The address which owns the funds.\n   * @param spender address The address which will spend the funds.\n   * @return A uint256 specifying the amount of tokens still available for the spender.\n   */\n  function allowance(\n    address owner,\n    address spender\n   )\n    public\n    view\n    returns (uint256)\n  {\n    return _allowed[owner][spender];\n  }\n\n  /**\n  * @dev Transfer token for a specified address\n  * @param to The address to transfer to.\n  * @param value The amount to be transferred.\n  */\n  function transfer(address to, uint256 value) public returns (bool) {\n    require(value <= _balances[msg.sender]);\n    require(to != address(0));\n\n    _balances[msg.sender] = _balances[msg.sender].sub(value);\n    _balances[to] = _balances[to].add(value);\n    emit Transfer(msg.sender, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender.\n   * Beware that changing an allowance with this method brings the risk that someone may use both the old\n   * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this\n   * race condition is to first reduce the spender\'s allowance to 0 and set the desired value afterwards:\n   * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n   * @param spender The address which will spend the funds.\n   * @param value The amount of tokens to be spent.\n   */\n  function approve(address spender, uint256 value) public returns (bool) {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = value;\n    emit Approval(msg.sender, spender, value);\n    return true;\n  }\n\n  /**\n   * @dev Transfer tokens from one address to another\n   * @param from address The address which you want to send tokens from\n   * @param to address The address which you want to transfer to\n   * @param value uint256 the amount of tokens to be transferred\n   */\n  function transferFrom(\n    address from,\n    address to,\n    uint256 value\n  )\n    public\n    returns (bool)\n  {\n    require(value <= _balances[from]);\n    require(value <= _allowed[from][msg.sender]);\n    require(to != address(0));\n\n    _balances[from] = _balances[from].sub(value);\n    _balances[to] = _balances[to].add(value);\n    _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(value);\n    emit Transfer(from, to, value);\n    return true;\n  }\n\n  /**\n   * @dev Increase the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To increment\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param addedValue The amount of tokens to increase the allowance by.\n   */\n  function increaseAllowance(\n    address spender,\n    uint256 addedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].add(addedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Decrease the amount of tokens that an owner allowed to a spender.\n   * approve should be called when allowed_[_spender] == 0. To decrement\n   * allowed value is better to use this function to avoid 2 calls (and wait until\n   * the first transaction is mined)\n   * From MonolithDAO Token.sol\n   * @param spender The address which will spend the funds.\n   * @param subtractedValue The amount of tokens to decrease the allowance by.\n   */\n  function decreaseAllowance(\n    address spender,\n    uint256 subtractedValue\n  )\n    public\n    returns (bool)\n  {\n    require(spender != address(0));\n\n    _allowed[msg.sender][spender] = (\n      _allowed[msg.sender][spender].sub(subtractedValue));\n    emit Approval(msg.sender, spender, _allowed[msg.sender][spender]);\n    return true;\n  }\n\n  /**\n   * @dev Internal function that mints an amount of the token and assigns it to\n   * an account. This encapsulates the modification of balances such that the\n   * proper events are emitted.\n   * @param account The account that will receive the created tokens.\n   * @param amount The amount that will be created.\n   */\n  function _mint(address account, uint256 amount) internal {\n    require(account != 0);\n    _totalSupply = _totalSupply.add(amount);\n    _balances[account] = _balances[account].add(amount);\n    emit Transfer(address(0), account, amount);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account.\n   * @param account The account whose tokens will be burnt.\n   * @param amount The amount that will be burnt.\n   */\n  function _burn(address account, uint256 amount) internal {\n    require(account != 0);\n    require(amount <= _balances[account]);\n\n    _totalSupply = _totalSupply.sub(amount);\n    _balances[account] = _balances[account].sub(amount);\n    emit Transfer(account, address(0), amount);\n  }\n\n  /**\n   * @dev Internal function that burns an amount of the token of a given\n   * account, deducting from the sender\'s allowance for said account. Uses the\n   * internal burn function.\n   * @param account The account whose tokens will be burnt.\n   * @param amount The amount that will be burnt.\n   */\n  function _burnFrom(address account, uint256 amount) internal {\n    require(amount <= _allowed[account][msg.sender]);\n\n    // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted,\n    // this function needs to emit an event with the updated approval.\n    _allowed[account][msg.sender] = _allowed[account][msg.sender].sub(\n      amount);\n    _burn(account, amount);\n  }\n}\n'})}),"\n",(0,a.jsx)(n.h2,{id:"further-reading",children:"Further Reading"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-20",children:"EIP-20: ERC-20 Token Standard"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://openzeppelin.com/",children:"OpenZeppelin - Tokens"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://openzeppelin.com/",children:"OpenZeppelin - ERC-20 Implementation"})}),"\n",(0,a.jsx)(n.li,{children:(0,a.jsx)(n.a,{href:"https://alchemyapi.io/",children:"Alchemy - Guide to Solidity ERC20 Tokens"})}),"\n"]}),"\n",(0,a.jsx)(n.hr,{}),"\n",(0,a.jsxs)(n.p,{children:["This documentation provides an overview of the ERC-20 standard adapted for TEN's Layer 2 solution. For a more detailed understanding and technical specifications, you can refer to the official ",(0,a.jsx)(n.a,{href:"https://eips.ethereum.org/EIPS/eip-20",children:"EIP-20 documentation"})," and TEN's official documentation."]})]})}function c(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(u,{...e})}):u(e)}}}]);