"use strict";(self.webpackChunkten_docs=self.webpackChunkten_docs||[]).push([[1203],{2459:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>o,default:()=>h,frontMatter:()=>s,metadata:()=>r,toc:()=>c});var i=t(5893),a=t(1151);const s={sidebar_position:4},o="Migrate your dApp to TEN",r={id:"introduction/developer-quickstart",title:"Migrate your dApp to TEN",description:'Migrating to TEN enables your dApp to leverage "Programmable Encryption". Below are steps to help you transition smoothly.',source:"@site/docs/introduction/developer-quickstart.md",sourceDirName:"introduction",slug:"/introduction/developer-quickstart",permalink:"/docs/introduction/developer-quickstart",draft:!1,unlisted:!1,editUrl:"https://github.com/ten-protocol/ten-documentation/blob/main/docs/introduction/developer-quickstart.md",tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"tutorialSidebar",previous:{title:"Technology",permalink:"/docs/introduction/technology"},next:{title:"Getting started",permalink:"/docs/category/getting-started"}},l={},c=[{value:"Key Migration Steps",id:"key-migration-steps",level:3},{value:"1. Configuring Hardhat",id:"1-configuring-hardhat",level:2},{value:"1.1 Installing the TEN Hardhat Plugin",id:"11-installing-the-ten-hardhat-plugin",level:3},{value:"1.2 Configuring <code>hardhat.config.js</code>",id:"12-configuring-hardhatconfigjs",level:3},{value:"2. Writing Smart Contracts for TEN",id:"2-writing-smart-contracts-for-ten",level:2},{value:"Step 1: Basic contract with a Public Variable",id:"step-1-basic-contract-with-a-public-variable",level:3},{value:"Code",id:"code",level:4},{value:"Explanation",id:"explanation",level:4},{value:"Step 2: Converting to a Private Variable with an explicit Getter Function",id:"step-2-converting-to-a-private-variable-with-an-explicit-getter-function",level:3},{value:"Code",id:"code-1",level:4},{value:"Explanation",id:"explanation-1",level:4},{value:"Step 3:  Data Access Control",id:"step-3--data-access-control",level:3},{value:"Code",id:"code-2",level:4},{value:"Explanation",id:"explanation-2",level:4},{value:"Step 4: Emitting Events - Default Visibility",id:"step-4-emitting-events---default-visibility",level:3},{value:"Code",id:"code-3",level:4},{value:"Explanation",id:"explanation-3",level:4},{value:"Step 5: Customizing Event Visibility",id:"step-5-customizing-event-visibility",level:3},{value:"Code",id:"code-4",level:4},{value:"Explanation",id:"explanation-4",level:4},{value:"Account Abstraction - Native Session Keys",id:"account-abstraction---native-session-keys",level:2},{value:"Solution overview",id:"solution-overview",level:3},{value:"Usage",id:"usage",level:3},{value:"When the game starts",id:"when-the-game-starts",level:4},{value:"The game",id:"the-game",level:4},{value:"Finishing the game",id:"finishing-the-game",level:4},{value:"Game Security",id:"game-security",level:2},{value:"The on-block-end callback",id:"the-on-block-end-callback",level:3}];function d(e){const n={a:"a",admonition:"admonition",br:"br",code:"code",em:"em",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.h1,{id:"migrate-your-dapp-to-ten",children:"Migrate your dApp to TEN"}),"\n",(0,i.jsx)(n.p,{children:'Migrating to TEN enables your dApp to leverage "Programmable Encryption". Below are steps to help you transition smoothly.'}),"\n",(0,i.jsx)(n.h3,{id:"key-migration-steps",children:"Key Migration Steps"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Update your Hardhat deployment to support the ",(0,i.jsx)(n.code,{children:"--network ten"})," option."]}),"\n",(0,i.jsx)(n.li,{children:"Add data protection logic to your view functions (if applicable)."}),"\n",(0,i.jsx)(n.li,{children:"Configure visibility rules for event logs and internal storage."}),"\n",(0,i.jsx)(n.li,{children:"Add the TEN onboarding widget to your JavaScript UI."}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"1-configuring-hardhat",children:"1. Configuring Hardhat"}),"\n",(0,i.jsx)(n.p,{children:"First, set up a Hardhat project if you haven't already."}),"\n",(0,i.jsx)(n.h3,{id:"11-installing-the-ten-hardhat-plugin",children:"1.1 Installing the TEN Hardhat Plugin"}),"\n",(0,i.jsxs)(n.p,{children:["To add TEN Network compatibility, install the ",(0,i.jsx)(n.code,{children:"ten-hardhat-plugin"}),":"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-bash",children:"npm install ten-hardhat-plugin\n"})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.em,{children:["You can use ",(0,i.jsx)(n.code,{children:"npm"})," or ",(0,i.jsx)(n.code,{children:"yarn"})," to install plugins."]})}),"\n",(0,i.jsxs)(n.h3,{id:"12-configuring-hardhatconfigjs",children:["1.2 Configuring ",(0,i.jsx)(n.code,{children:"hardhat.config.js"})]}),"\n",(0,i.jsxs)(n.p,{children:["Modify ",(0,i.jsx)(n.code,{children:"hardhat.config.js"})," in your project\u2019s root directory as follows:"]}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-javascript",children:'import { HardhatUserConfig } from "hardhat/config";\nimport "@nomiclabs/hardhat-waffle";\nimport "ten-hardhat-plugin";\n\nmodule.exports = {\n  solidity: "0.8.10",\n  networks: {\n    hardhat: {\n        // Configuration for the Hardhat Network\n    },\n    ten: {\n        url: "https://testnet.ten.xyz/v1/",\n        chainId: 443,\n        accounts: ["your-private-key"],\n    },\n  },\n};\n\nexport default config;\n'})}),"\n",(0,i.jsx)(n.p,{children:"Once configured, you can start writing or migrating your smart contracts."}),"\n",(0,i.jsx)(n.h2,{id:"2-writing-smart-contracts-for-ten",children:"2. Writing Smart Contracts for TEN"}),"\n",(0,i.jsx)(n.p,{children:"TEN executes smart contracts within the EVM similarly to Ethereum, so you can reuse your existing code.\nHowever, the execution and the internal state are hidden from everyone, including node operators and the sequencer."}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:"TEN encrypts both the execution and its internal database using Trusted Execution Environments (TEEs)."})}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.a,{href:"https://docs.alchemy.com/reference/eth-getstorageat",children:"getStorageAt"})," method is disabled by default on TEN, so data access relies on view functions that you define.\nPublic variables remain accessible as Solidity automatically creates getters for them."]}),"\n",(0,i.jsx)(n.p,{children:"Let's illustrate with a basic storage dApp example where users can store and retrieve a number."}),"\n",(0,i.jsxs)(n.p,{children:["At every step, we'll add a new feature and explain the difference between ",(0,i.jsx)(n.code,{children:"TEN"})," and ",(0,i.jsx)(n.code,{children:"Ethereum"}),"."]}),"\n",(0,i.jsx)(n.h3,{id:"step-1-basic-contract-with-a-public-variable",children:"Step 1: Basic contract with a Public Variable"}),"\n",(0,i.jsx)(n.h4,{id:"code",children:"Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract StorageExample {\n    mapping(address => uint256) public storedValues;\n\n    function storeValue(uint256 value) public {\n        storedValues[tx.origin] = value;\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"explanation",children:"Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["In this step, we created a public variable ",(0,i.jsx)(n.code,{children:"storedValues"})," that maps the provided value to the address of the user who called the ",(0,i.jsx)(n.code,{children:"storeValue"})," function."]}),"\n",(0,i.jsx)(n.p,{children:"Because the variable is public, Solidity will provide a default public getter for it."}),"\n",(0,i.jsx)(n.p,{children:"Since there are no data access restrictions, on both Ethereum and TEN, everyone will be able to read the values of all users."}),"\n",(0,i.jsx)(n.h3,{id:"step-2-converting-to-a-private-variable-with-an-explicit-getter-function",children:"Step 2: Converting to a Private Variable with an explicit Getter Function"}),"\n",(0,i.jsx)(n.h4,{id:"code-1",children:"Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:"contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n    }\n    \n    function getValue(address account) public view returns (uint256) {\n        return _storedValues[account];\n    }\n}\n"})}),"\n",(0,i.jsx)(n.h4,{id:"explanation-1",children:"Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"storedValues"})," variable is now private, and we added a basic ",(0,i.jsx)(n.code,{children:"getValue"})," function for users to retrieve their value."]}),"\n",(0,i.jsxs)(n.p,{children:["On both Ethereum and TEN, anyone can call ",(0,i.jsx)(n.code,{children:"getValue"})," to retrieve any value.",(0,i.jsx)(n.br,{}),"\n","On Ethereum, ",(0,i.jsx)(n.code,{children:"_storedValues"})," can also be accessed directly with ",(0,i.jsx)(n.code,{children:"getStorageAt"})]}),"\n",(0,i.jsx)(n.h3,{id:"step-3--data-access-control",children:"Step 3:  Data Access Control"}),"\n",(0,i.jsx)(n.p,{children:"In this step, we'll add restrictions so users can only access their own data."}),"\n",(0,i.jsx)(n.h4,{id:"code-2",children:"Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorized!");\n        return _storedValues[account];\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"explanation-2",children:"Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["The key line is: ",(0,i.jsx)(n.code,{children:'require(tx.origin == account, "Not authorized!");'}),", which ensures that the caller of the view function is the owner of the data."]}),"\n",(0,i.jsx)(n.admonition,{type:"info",children:(0,i.jsx)(n.p,{children:'TEN uses  "Viewing Keys" to authenticate view function calls.'})}),"\n",(0,i.jsx)(n.p,{children:(0,i.jsxs)(n.strong,{children:["When deployed on TEN, this code guarantees that all users can only access their own values, and nobody can read the ",(0,i.jsx)(n.code,{children:"_storedValues"}),"."]})}),"\n",(0,i.jsx)(n.h3,{id:"step-4-emitting-events---default-visibility",children:"Step 4: Emitting Events - Default Visibility"}),"\n",(0,i.jsx)(n.p,{children:"Event logs notify UIs about state changes in smart contracts."}),"\n",(0,i.jsx)(n.p,{children:"To improve our smart contract, we\u2019ll emit an event when a user stores a value and milestone events when a specific size threshold is met."}),"\n",(0,i.jsx)(n.h4,{id:"code-3",children:"Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n    uint256 private totalCalls = 0;\n\n    event DataChanged(address indexed account, uint256 newValue);\n    event MilestoneReached(uint256 noStoredValues);\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n        emit DataChanged(tx.origin, value);\n        totalCalls++;\n        if (totalCalls % 1000 == 0) {\n            emit MilestoneReached(totalCalls);\n        }\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorized!");\n        return _storedValues[account];\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"explanation-3",children:"Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["Notice how we defined the two events: ",(0,i.jsx)(n.code,{children:"DataChanged"})," and ",(0,i.jsx)(n.code,{children:"MilestoneReached"}),", and are emitting them in the ",(0,i.jsx)(n.code,{children:"storeValue"})," function."]}),"\n",(0,i.jsx)(n.p,{children:"In Ethereum, everyone can query and subscribe to these events. This obviously can't be the case for TEN because it would completely break the functionality."}),"\n",(0,i.jsx)(n.p,{children:"Notice how in this version, we have no configuration for event log visibility, so we are relying on the default rules."}),"\n",(0,i.jsx)(n.p,{children:"Rule 1: Event logs that contain EOAs as indexed fields (topics) are only visible to those EOAs.\nRule 2: Event logs that don't contain any EOA are visible to everyone."}),"\n",(0,i.jsx)(n.p,{children:"In our case, the default rules ensure that:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"DataChanged"})," is visible only to the address that is storing the value."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"MilestoneReached"})," is publicly visible."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"step-5-customizing-event-visibility",children:"Step 5: Customizing Event Visibility"}),"\n",(0,i.jsx)(n.p,{children:"The default visibility rules are a good starting point, but complex dApps require greater flexibility."}),"\n",(0,i.jsx)(n.p,{children:"TEN give you explicit control over event visibility."}),"\n",(0,i.jsx)(n.h4,{id:"code-4",children:"Code"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'interface ContractTransparencyConfig {\n    enum Field { TOPIC1, TOPIC2, TOPIC3, SENDER, EVERYONE }\n    enum ContractCfg { TRANSPARENT, PRIVATE }\n\n    struct EventLogConfig {\n        bytes32 eventSignature;\n        Field[] visibleTo;\n    }\n\n    struct VisibilityConfig {\n        ContractCfg contractCfg;\n        EventLogConfig[] eventLogConfigs;\n    }\n\n    function visibilityRules() external pure returns (VisibilityConfig memory);\n}\n\ncontract StorageExample is ContractTransparencyConfig {\n    mapping(address => uint256) private _storedValues;\n    uint256 private totalCalls = 0;\n\n    event DataChanged(address indexed account, uint256 newValue);\n    event MilestoneReached(uint256 noStoredValues);\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n        emit DataChanged(tx.origin, value);\n        totalCalls++;\n        if (totalCalls % 1000 == 0) {\n            emit MilestoneReached(totalCalls);\n        }\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorized!");\n        return _storedValues[account];\n    }\n\n    function visibilityRules() external pure override returns (VisibilityConfig memory) {\n        EventLogConfig[]  memory eventLogConfigs = new EventLogConfig[](2);\n\n        // the signature of "event DataChanged(address indexed account, uint256 newValue);"\n        bytes32 dataChangedEventSig = hex"0xec851d5c322f7f1dd5581f7432e9f6683a8709a4b1ca754ccb164742b82a7d2f";\n        Field[]  memory relevantTo = new Field[](2);\n        relevantTo[0] = Field.TOPIC1;\n        relevantTo[1] = Field.SENDER;\n        eventLogConfigs[0] = EventLogConfig(dataChangedEventSig, relevantTo);\n\n        // the signature of "event MilestoneReached(uint256 noStoredValues);"\n        bytes32 milestoneReachedEventSig = hex"0xd41033274424d56dd572e7196fb4230cf4141d546b91fc00555cab8403965924";\n        Field[]  memory relevantTo = new Field[](1);\n        relevantTo[0] = Field.EVERYONE;\n        eventLogConfigs[1] = EventLogConfig(milestoneReachedEventSig, relevantTo);\n\n        return VisibilityConfig(ContractCfg.PRIVATE, eventLogConfigs);\n    }\n}\n'})}),"\n",(0,i.jsx)(n.h4,{id:"explanation-4",children:"Explanation"}),"\n",(0,i.jsxs)(n.p,{children:["The ",(0,i.jsx)(n.code,{children:"ContractTransparencyConfig"})," interface is known by the TEN platform.\nWhen a contract is deployed, the platform will call the ",(0,i.jsx)(n.code,{children:"visibilityRules"})," function, and store the ",(0,i.jsx)(n.code,{children:"VisibilityConfig"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"For each event type, you can configure which fields can access it.\nThis allows the developer to configure an event to be public even if it has EOAs or to allow the sender of the transaction to access events emitted even if the address is not in the event."}),"\n",(0,i.jsxs)(n.p,{children:["Notice how in the ",(0,i.jsx)(n.code,{children:"visibilityRules"})," above, we configure the ",(0,i.jsx)(n.code,{children:"DataChanged"})," event to be visible to the first field and the sender, and the ",(0,i.jsx)(n.code,{children:"MilestoneReached"})," to be visible to everyone."]}),"\n",(0,i.jsxs)(n.p,{children:["The other configuration: ",(0,i.jsx)(n.code,{children:"VisibilityConfig.contractCfg"})," applies to the entire contract:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ContractCfg.TRANSPARENT"}),": The contracts will have public storage and events, behaving exactly like Ethereum."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"ContractCfg.PRIVATE"}),": The default TEN behaviour, where the storage is not accessible and the events are individually configurable."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"account-abstraction---native-session-keys",children:"Account Abstraction - Native Session Keys"}),"\n",(0,i.jsxs)(n.p,{children:["The key feature of ",(0,i.jsx)(n.a,{href:"https://medium.com/p/2e85bde4c54d",children:'"Account Abstraction"'}),' (EIP-4337) is "Session keys"(SK) through a proxy smart contract.\nSKs allow users to interact with the blockchain without having to sign every transaction, which is a major UX improvement.']}),"\n",(0,i.jsx)(n.p,{children:'TEN supports "native" SKs - these are managed by the platform and do not require a proxy contract.'}),"\n",(0,i.jsx)(n.p,{children:"In TEN, SKs are managed by dApp developers through dedicated RPC endpoints."}),"\n",(0,i.jsx)(n.h3,{id:"solution-overview",children:"Solution overview"}),"\n",(0,i.jsx)(n.p,{children:"Imagine you're developing an on-chain game, and you want a smooth UX without the distraction of signing every move."}),"\n",(0,i.jsx)(n.p,{children:'Conceptually, the game will create a session key (SK) for the user, then ask the user to move some funds to that address, and then create "move" transactions signed with the SK.'}),"\n",(0,i.jsx)(n.p,{children:"If the game were to create the SK in the browser, there would be a risk of the user losing the SK, and the funds associated with it, in case of an accidental exit.\nWith TEN, the dApp developer doesn't have to worry about this, because the SKs are managed by TEEs."}),"\n",(0,i.jsx)(n.h3,{id:"usage",children:"Usage"}),"\n",(0,i.jsx)(n.p,{children:"The below describe the implementation steps for the game developer - which is the main usecase for SKs.\nNote that it can be used for any dApp that requires a no-click UX."}),"\n",(0,i.jsx)(n.h4,{id:"when-the-game-starts",children:"When the game starts"}),"\n",(0,i.jsx)(n.p,{children:"Before the user can start playing, the game must create the SK and ask the user to move some funds to that address.\nThe funds will be used to pay for moves."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:["Call the RPC ",(0,i.jsx)(n.code,{children:"sessionkeys_Create"})," - without any parameters. This will return a hex-encoded address of the SK."]}),"\n",(0,i.jsx)(n.li,{children:'Create a normal transaction that transfers some ETH to the SK. The amount depends on how many "moves" the user is prepared to prepay for.'}),"\n",(0,i.jsx)(n.li,{children:"Ask the user to sign this transaction with their normal wallet, and submit it to the network using the library of your choice."}),"\n",(0,i.jsxs)(n.li,{children:["Once the receipt is received, call ",(0,i.jsx)(n.code,{children:"sessionkeys_Activate"}),"."]}),"\n"]}),"\n",(0,i.jsx)(n.h4,{id:"the-game",children:"The game"}),"\n",(0,i.jsxs)(n.p,{children:["After activation of the SK, create a transaction for each move, but don't ask the user to sign them.\nInstead, submit them to the network unsigned using the RPCs: ",(0,i.jsx)(n.code,{children:"eth_sendRawTransaction"})," or ",(0,i.jsx)(n.code,{children:"eth_sendTransaction"}),"."]}),"\n",(0,i.jsx)(n.p,{children:"Because the SK is active, the platform will sign the transactions on behalf of the user."}),"\n",(0,i.jsx)(n.p,{children:"As a game developer, you are responsible to keep track of the balance of the SK. You can also query the network for the balance of the address.\nIf the SK runs out of balance, you have to ask the user to move more funds to the SK."}),"\n",(0,i.jsx)(n.h4,{id:"finishing-the-game",children:"Finishing the game"}),"\n",(0,i.jsx)(n.p,{children:"When a game ends, you have to move the remaining funds back to the main address and deactivate the key."}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"create a Tx that moves the funds back from the SK to the main address. Submit it unsigned, because the funds are controlled by the SK."}),"\n",(0,i.jsxs)(n.li,{children:["call the RPC: ",(0,i.jsx)(n.code,{children:"sessionkeys_Deactivate"}),"- from now on, unsigned transactions will no longer be signed by the SK."]}),"\n"]}),"\n",(0,i.jsx)(n.h2,{id:"game-security",children:"Game Security"}),"\n",(0,i.jsx)(n.p,{children:"Every on-chain game developer knows that every move that relies on entropy must be executed in two steps."}),"\n",(0,i.jsxs)(n.p,{children:["Imagine you implement an on-chain coin flip game. The player pays 0.1ETH to choose ",(0,i.jsx)(n.code,{children:"Heads"})," or ",(0,i.jsx)(n.code,{children:"Tails"}),".\nIf they win, they receive 0.2ETH, otherwise they lose the 0.1ETH.\nEven if randomness is unpredictable, this simple game can be exploited in several ways:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"The attacker can create a \u201cproxy\u201d smart contract to play on their behalf. Using a similar mechanism to flash loans in DeFi: the proxy is programmed to make multiple actions, and only \u201ccommit\u201d if it can obtain a profit. In our case, if the coin flip is losing, the proxy can just revert. The only cost will be the gas burned."}),"\n",(0,i.jsx)(n.li,{children:"Transactions consume gas, and the gas cost can inadvertently reveal information. For instance, if a winning move is more computationally intensive than a losing one, players could deduce optimal moves by estimating gas costs for various actions."}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"The typical solution is to use a commit-reveal scheme. The player commits to a move, and then reveals it. This way, the player can't change their mind after seeing the result.\nThis solution has the major drawback that it introduces extra complexity, latency and cost."}),"\n",(0,i.jsx)(n.h3,{id:"the-on-block-end-callback",children:"The on-block-end callback"}),"\n",(0,i.jsx)(n.p,{children:"The best solution is to decouple the move from the execution without increasing the latency or the cost.\nThis way, the side-channel attacks are no longer possible because the move is not executed immediately.\nTo avoid increasing the latency, the move must be executed at the end of the block."}),"\n",(0,i.jsx)(n.p,{children:"See below a simple implementation of the coin flip game using the TEN platform:"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-solidity",children:'// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n// this interface is known by the TEN system contract\ninterface TenCallbacks {\n    function register(bytes calldata) external payable returns (uint256);\n}\n\ncontract CoinFlip {\n    // Event to emit the result of the coin flip\n    event CoinFlipResult(address indexed player, bool didWin, uint256 randomNumber);\n\n    private TenCallbacks tenCallbacks;\n\n    modifier onlyTenSystemCall() { \n        require(msg.sender == address(tenCallbacks));\n        _;\n    }\n\n    // you have to pass in the address of the callbacks contract\n    constructor(address _tenCallbacksAddress) {\n        tenCallbacks = TenCallbacks(_tenCallbacksAddress);\n    }\n\n    // Function to initiate a coin flip. \n    // Notice how it doesn\'t execute the coin flip directly, but instead registers a callback.\n    function flipCoin(bool isHeads) external payable {\n        // Assume doFlipCoin costs 50_000 gas;\n        // We deduct a predetermined amount from the bet to pay for delayed execution.\n        uint256 etherGasForCoinFlip = 50_000*block.basefee;\n        require(msg.value > etherGasForCoinFlip, "Insufficent gas");\n\n        // Encode the function we want to be called by the TEN system contract.\n        bytes memory callbackTargetInfo = abi.encodeWithSelector(this.doFlipCoin.selector, msg.sender, msg.value - etherGasForCoinFlip, isHeads);\n\n        tenCallbacks.register{value: etherGasForCoinFlip}(callbackTargetInfo);\n    }\n\n    // Function to simulate a coin flip - notice that this must only be callable by the ten system contract.\n    // This function is called by the TEN platform as a synthetic transaction in the same block as the user transaction.\n    function doFlipCoin(address bettor, uint256 stake, bool wantsHeads) external onlyTenSystemCall {\n        // Assume getRandomNumber() is a function that returns a random number\n        uint256 randomNumber = getRandomNumber();\n\n        // Simulate a coin flip: 0 for tails, 1 for heads\n        bool isHeads = (randomNumber % 2) == 1;\n\n        if (wantsHeads == isHeads) {\n            //pay out to winner\n            (bool success, ) = payable(bettor).call{value: stake*2}("");\n            require(success, "Payment failed.");\n        }\n        // Emit the result of the coin flip\n        emit CoinFlipResult(msg.sender, isHeads, randomNumber);\n    }\n\n    function getRandomNumber() internal view returns (uint256) {\n        return block.prevrandao;\n    }\n}\n'})})]})}function h(e={}){const{wrapper:n}={...(0,a.a)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},1151:(e,n,t)=>{t.d(n,{Z:()=>r,a:()=>o});var i=t(7294);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);