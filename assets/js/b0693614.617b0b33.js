"use strict";(self.webpackChunkten_docs=self.webpackChunkten_docs||[]).push([[202],{1291:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>r,contentTitle:()=>l,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>c});const i=JSON.parse('{"id":"smart-contract-features/data-access","title":"Data Access","description":"Solidity encapsulates \\"private\\" state variables in a way that prevents them from being accessed by other contracts.","source":"@site/docs/3-smart-contract-features/1-data-access.md","sourceDirName":"3-smart-contract-features","slug":"/smart-contract-features/data-access","permalink":"/docs/smart-contract-features/data-access","draft":false,"unlisted":false,"editUrl":"https://github.com/ten-protocol/ten-documentation/blob/main/docs/3-smart-contract-features/1-data-access.md","tags":[],"version":"current","sidebarPosition":1,"frontMatter":{"sidebar_position":1},"sidebar":"tutorialSidebar","previous":{"title":"Smart Contract Features","permalink":"/docs/category/smart-contract-features"},"next":{"title":"Native secure entropy","permalink":"/docs/smart-contract-features/native-entropy"}}');var a=t(4848),s=t(8453);const o={sidebar_position:1},l="Data Access",r={},c=[{value:"Data Access Control Rules",id:"data-access-control-rules",level:2},{value:"Data Access Control Example",id:"data-access-control-example",level:2},{value:"Step 1: Basic contract with a Public Variable",id:"step-1-basic-contract-with-a-public-variable",level:3},{value:"Code",id:"code",level:4},{value:"Explanation",id:"explanation",level:4},{value:"Step 2: Converting to a Private Variable with an explicit Getter Function",id:"step-2-converting-to-a-private-variable-with-an-explicit-getter-function",level:3},{value:"Code",id:"code-1",level:4},{value:"Explanation",id:"explanation-1",level:4},{value:"Step 3: Data Access Control",id:"step-3-data-access-control",level:3},{value:"Code",id:"code-2",level:4},{value:"Explanation",id:"explanation-2",level:4},{value:"Step 4: Emitting Events - Default Visibility",id:"step-4-emitting-events---default-visibility",level:3},{value:"Code",id:"code-3",level:4},{value:"Explanation",id:"explanation-3",level:4},{value:"Step 5: Customising Event Visibility",id:"step-5-customising-event-visibility",level:3},{value:"Code",id:"code-4",level:4},{value:"Explanation",id:"explanation-4",level:4}];function d(e){const n={a:"a",br:"br",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"data-access",children:"Data Access"})}),"\n",(0,a.jsx)(n.p,{children:'Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.'}),"\n",(0,a.jsxs)(n.p,{children:["However, private variables are readable externally via ",(0,a.jsx)(n.a,{href:"https://docs.alchemy.com/reference/eth-getstorageat",children:"getStorageAt"}),", meaning contracts can't truly have secrets."]}),"\n",(0,a.jsx)(n.p,{children:'TEN overcomes this limitation by offering "Data Access Control" primitives.'}),"\n",(0,a.jsx)(n.p,{children:"To achieve this, we had to:"}),"\n",(0,a.jsxs)(n.ol,{children:["\n",(0,a.jsx)(n.li,{children:"Run the Ethereum Virtual Machine inside a Trusted Execution Environment (TEE) and store the state in encrypted storage. This prevents the node operator from accessing the data."}),"\n",(0,a.jsxs)(n.li,{children:["Disable the ",(0,a.jsx)(n.code,{children:"getStorageAt"})," method, so now contracts can have secrets (as long as the ",(0,a.jsx)(n.code,{children:"private"})," state variables are not exposed via public view functions). This prevents anyone with RPC access to the node from reading the data."]}),"\n",(0,a.jsxs)(n.li,{children:['Authenticate "view function calls" so that the smart contract knows who is calling the view function. Without this feature there is no "Data Access ',(0,a.jsx)(n.strong,{children:"Control"}),"\", because the dApp developer can't write access control logic."]}),"\n",(0,a.jsx)(n.li,{children:"Event logs are another way to expose data from a contract to the outside world. A practical platform needs a way to configure who can read the various event logs."}),"\n",(0,a.jsx)(n.li,{children:'Control access to the "Transaction Receipts", which contain the logs and status of the transaction.'}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"data-access-control-rules",children:"Data Access Control Rules"}),"\n",(0,a.jsx)(n.p,{children:"Here, we'll list the platform rules. The examples below will showcase how exactly to use these rules in practice."}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'Any contract can be configured to be "transparent" or "private". By default, it is "private", which means the internal storage is not accessible. "Transparent" contracts behave exactly like Ethereum.'}),"\n",(0,a.jsxs)(n.li,{children:["Any RPC call accessing data like: ",(0,a.jsx)(n.code,{children:"eth_call"}),", ",(0,a.jsx)(n.code,{children:"eth_estimateGas"}),", ",(0,a.jsx)(n.code,{children:"eth_getTransactionReceipt"}),", ",(0,a.jsx)(n.code,{children:"eth_logs"}),", must be signed by a ",(0,a.jsx)(n.a,{href:"/docs/write-ten-dapp/high-level-concepts#ten-gateway",children:"viewing key (VK)"}),". The VK itself must be signed by the main account. (Note that this is behind the scenes.)"]}),"\n",(0,a.jsxs)(n.li,{children:["Event log visibility is configurable. Each event log can be visible to one or multiple of the topics (indexed fields), and the sender of the transaction, only if the topic is the ",(0,a.jsx)(n.code,{children:"address"}),' of an "Externally owned Account" (EOA). The event log can also be configured to be "public" - visible to everyone.']}),"\n",(0,a.jsxs)(n.li,{children:["When there is no configuration, the default event log visibility is:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"Rule 1: Event logs that contain EOAs as topics are only visible to those EOAs."}),"\n",(0,a.jsx)(n.li,{children:"Rule 2: Event logs that don't contain any EOA are visible to everyone."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:["As a general rule, transaction receipts are visible to:","\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:"anyone who can access at least one event log emitted by that transaction,"}),"\n",(0,a.jsx)(n.li,{children:"the sender of the transaction, and"}),"\n",(0,a.jsx)(n.li,{children:"everyone, if the transaction called a transparent contract."}),"\n"]}),"\n"]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"eth_getStorageAt"}),' can be called on "transparent" contracts.']}),"\n"]}),"\n",(0,a.jsx)(n.h2,{id:"data-access-control-example",children:"Data Access Control Example"}),"\n",(0,a.jsx)(n.p,{children:"Let's illustrate with a basic storage dApp example where users can store and retrieve a number."}),"\n",(0,a.jsxs)(n.p,{children:["At every step, we'll add a new feature and explain the difference between ",(0,a.jsx)(n.code,{children:"TEN"})," and ",(0,a.jsx)(n.code,{children:"Ethereum"}),"."]}),"\n",(0,a.jsx)(n.h3,{id:"step-1-basic-contract-with-a-public-variable",children:"Step 1: Basic contract with a Public Variable"}),"\n",(0,a.jsx)(n.h4,{id:"code",children:"Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ncontract StorageExample {\n    mapping(address => uint256) public storedValues;\n\n    function storeValue(uint256 value) public {\n        storedValues[tx.origin] = value;\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"explanation",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["In this step, we created a public variable ",(0,a.jsx)(n.code,{children:"storedValues"})," that maps the provided value to the address of the user who called the ",(0,a.jsx)(n.code,{children:"storeValue"})," function."]}),"\n",(0,a.jsx)(n.p,{children:"Because the variable is public, Solidity will provide a default public getter for it."}),"\n",(0,a.jsx)(n.p,{children:"Since there are no data access restrictions, on both Ethereum and TEN, everyone will be able to read the values of all users by just calling the default public getter."}),"\n",(0,a.jsx)(n.h3,{id:"step-2-converting-to-a-private-variable-with-an-explicit-getter-function",children:"Step 2: Converting to a Private Variable with an explicit Getter Function"}),"\n",(0,a.jsx)(n.h4,{id:"code-1",children:"Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:"contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n    }\n    \n    function getValue(address account) public view returns (uint256) {\n        return _storedValues[account];\n    }\n}\n"})}),"\n",(0,a.jsx)(n.h4,{id:"explanation-1",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.code,{children:"storedValues"})," variable is now private, and we added a basic ",(0,a.jsx)(n.code,{children:"getValue"})," function for users to retrieve their value."]}),"\n",(0,a.jsxs)(n.p,{children:["On both Ethereum and TEN, anyone can call ",(0,a.jsx)(n.code,{children:"getValue"})," to retrieve any value.",(0,a.jsx)(n.br,{}),"\n","On Ethereum, ",(0,a.jsx)(n.code,{children:"_storedValues"})," can also be accessed directly with ",(0,a.jsx)(n.code,{children:"getStorageAt"})]}),"\n",(0,a.jsx)(n.h3,{id:"step-3-data-access-control",children:"Step 3: Data Access Control"}),"\n",(0,a.jsx)(n.p,{children:"In this step, we'll add restrictions so users can only access their own data."}),"\n",(0,a.jsx)(n.h4,{id:"code-2",children:"Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorised!");\n        return _storedValues[account];\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"explanation-2",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["The key line is: ",(0,a.jsx)(n.code,{children:'require(tx.origin == account, "Not authorised!");'}),", which ensures that the caller of the view function is the owner of the data."]}),"\n",(0,a.jsx)(n.p,{children:(0,a.jsxs)(n.strong,{children:["When deployed on TEN, this code guarantees that all users can only access their own values, and nobody can read the ",(0,a.jsx)(n.code,{children:"_storedValues"}),"."]})}),"\n",(0,a.jsxs)(n.p,{children:["On Ethereum, the ",(0,a.jsx)(n.code,{children:"tx.origin"})," is not authenticated, so the check above is not effective and ",(0,a.jsx)(n.code,{children:"eth_getStorageAt"})," is available."]}),"\n",(0,a.jsx)(n.h3,{id:"step-4-emitting-events---default-visibility",children:"Step 4: Emitting Events - Default Visibility"}),"\n",(0,a.jsx)(n.p,{children:"Event logs notify UIs about state changes in smart contracts."}),"\n",(0,a.jsx)(n.p,{children:"To improve our smart contract, we\u2019ll emit an event when a user stores a value and milestone events when a specific size threshold is met."}),"\n",(0,a.jsx)(n.h4,{id:"code-3",children:"Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'contract StorageExample {\n    mapping(address => uint256) private _storedValues;\n    uint256 private totalCalls = 0;\n\n    event DataChanged(address indexed account, uint256 newValue);\n    event MilestoneReached(uint256 noStoredValues);\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n        emit DataChanged(tx.origin, value);\n        totalCalls++;\n        if (totalCalls % 1000 == 0) {\n            emit MilestoneReached(totalCalls);\n        }\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorised!");\n        return _storedValues[account];\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"explanation-3",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["Notice how we defined the two events: ",(0,a.jsx)(n.code,{children:"DataChanged"})," and ",(0,a.jsx)(n.code,{children:"MilestoneReached"}),", and are emitting them in the ",(0,a.jsx)(n.code,{children:"storeValue"})," function."]}),"\n",(0,a.jsx)(n.p,{children:"In Ethereum, everyone can query and subscribe to these events. If this was possible on TEN, it would completely break the functionality because you can see all the secret values."}),"\n",(0,a.jsx)(n.p,{children:"Notice how in this version, we have no configuration for event log visibility, so we are relying on the default rules:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsx)(n.li,{children:'Rule 1: Event logs that contain ("Externally owned Account") EOAs as indexed fields (topics) are only visible to those EOAs.'}),"\n",(0,a.jsx)(n.li,{children:"Rule 2: Event logs that don't contain any EOA are visible to everyone."}),"\n"]}),"\n",(0,a.jsx)(n.p,{children:"In our case, the default rules ensure that:"}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"DataChanged"})," is visible only to the address that is storing the value."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"MilestoneReached"})," is publicly visible."]}),"\n"]}),"\n",(0,a.jsx)(n.h3,{id:"step-5-customising-event-visibility",children:"Step 5: Customising Event Visibility"}),"\n",(0,a.jsx)(n.p,{children:"The default visibility rules are a good starting point, but complex dApps require greater flexibility."}),"\n",(0,a.jsx)(n.p,{children:"TEN gives you explicit control over event visibility."}),"\n",(0,a.jsx)(n.h4,{id:"code-4",children:"Code"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-solidity",children:'\n// when implementing this interface, the platform will configure the visibility rules\ninterface ContractTransparencyConfig {\n    enum Field { TOPIC1, TOPIC2, TOPIC3, SENDER, EVERYONE }\n    enum ContractCfg { TRANSPARENT, PRIVATE }\n\n    struct EventLogConfig {\n        bytes32 eventSignature;\n        Field[] visibleTo;\n    }\n\n    struct VisibilityConfig {\n        ContractCfg contractCfg;\n        EventLogConfig[] eventLogConfigs;\n    }\n\n    function visibilityRules() external pure returns (VisibilityConfig memory);\n}\n\ncontract StorageExample is ContractTransparencyConfig {\n    mapping(address => uint256) private _storedValues;\n    uint256 private totalCalls = 0;\n\n    event DataChanged(address indexed account, uint256 newValue);\n    event MilestoneReached(uint256 noStoredValues);\n\n    function storeValue(uint256 value) public {\n        _storedValues[tx.origin] = value;\n        emit DataChanged(tx.origin, value);\n        totalCalls++;\n        if (totalCalls % 1000 == 0) {\n            emit MilestoneReached(totalCalls);\n        }\n    }\n\n    function getValue(address account) public view returns (uint256) {\n        require(tx.origin == account, "Not authorised!");\n        return _storedValues[account];\n    }\n\n    function visibilityRules() external pure override returns (VisibilityConfig memory) {\n        EventLogConfig[]  memory eventLogConfigs = new EventLogConfig[](2);\n\n        // the signature of "event DataChanged(address indexed account, uint256 newValue);"\n        bytes32 dataChangedEventSig = hex"0xec851d5c322f7f1dd5581f7432e9f6683a8709a4b1ca754ccb164742b82a7d2f";\n        Field[]  memory relevantTo = new Field[](2);\n        relevantTo[0] = Field.TOPIC1;\n        relevantTo[1] = Field.SENDER;\n        eventLogConfigs[0] = EventLogConfig(dataChangedEventSig, relevantTo);\n\n        // the signature of "event MilestoneReached(uint256 noStoredValues);"\n        bytes32 milestoneReachedEventSig = hex"0xd41033274424d56dd572e7196fb4230cf4141d546b91fc00555cab8403965924";\n        Field[]  memory relevantTo = new Field[](1);\n        relevantTo[0] = Field.EVERYONE;\n        eventLogConfigs[1] = EventLogConfig(milestoneReachedEventSig, relevantTo);\n\n        return VisibilityConfig(ContractCfg.PRIVATE, eventLogConfigs);\n    }\n}\n'})}),"\n",(0,a.jsx)(n.h4,{id:"explanation-4",children:"Explanation"}),"\n",(0,a.jsxs)(n.p,{children:["The ",(0,a.jsx)(n.a,{href:"https://github.com/ten-protocol/go-ten/blob/main/contracts/src/system/config/IContractTransparencyConfig.sol",children:(0,a.jsx)(n.code,{children:"ContractTransparencyConfig"})})," interface is known by the TEN platform.\nWhen a contract is deployed, the platform will call the ",(0,a.jsx)(n.code,{children:"visibilityRules"})," function, and store the ",(0,a.jsx)(n.code,{children:"VisibilityConfig"}),"."]}),"\n",(0,a.jsx)(n.p,{children:"For each event type, you can configure which fields can access it."}),"\n",(0,a.jsxs)(n.p,{children:["Notice how in the ",(0,a.jsx)(n.code,{children:"visibilityRules"})," above, we configure the ",(0,a.jsx)(n.code,{children:"DataChanged"})," event to be visible to the first field and the sender, and the ",(0,a.jsx)(n.code,{children:"MilestoneReached"})," to be visible to everyone."]}),"\n",(0,a.jsxs)(n.p,{children:["The other configuration: ",(0,a.jsx)(n.code,{children:"VisibilityConfig.contractCfg"})," applies to the entire contract:"]}),"\n",(0,a.jsxs)(n.ul,{children:["\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ContractCfg.TRANSPARENT"}),": The contracts will have public storage and events, behaving exactly like Ethereum."]}),"\n",(0,a.jsxs)(n.li,{children:[(0,a.jsx)(n.code,{children:"ContractCfg.PRIVATE"}),": The default TEN behaviour, where the storage is not accessible and the events are individually configurable."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,s.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>o,x:()=>l});var i=t(6540);const a={},s=i.createContext(a);function o(e){const n=i.useContext(s);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:o(e.components),i.createElement(s.Provider,{value:n},e.children)}}}]);