# TEN Documentation

> Comprehensive guide to TEN protocol

- [TEN Documentation](/index.md)

## markdown-page

You don't need React to write simple standalone pages.

- [Markdown page example](/markdown-page.md): You don't need React to write simple standalone pages.

## search

- [Search the documentation](/search.md)

## docs


### category


#### governance

- [Governance](/docs/category/governance.md)

#### micar-white-papers

MiCAR regulatory whitepapers and documentation

- [MiCAR White Papers](/docs/category/micar-white-papers.md): MiCAR regulatory whitepapers and documentation

#### run-a-ten-node

- [Run a TEN node](/docs/category/run-a-ten-node.md)

#### smart-contract-features

- [Smart Contract Features](/docs/category/smart-contract-features.md)

#### ten-network-association

- [TEN Network Association](/docs/category/ten-network-association.md)

#### write-a-ten-dapp

- [Write a TEN dApp](/docs/category/write-a-ten-dapp.md)

### governance


#### governance

TEN's governance is explicit, transparent, and draws inspiration from the experiences of Bitcoin and Ethereum. In a decentralized system, control can be:

- [Governance](/docs/governance/governance.md): TEN's governance is explicit, transparent, and draws inspiration from the experiences of Bitcoin and Ethereum. In a decentralized system, control can be:

#### ten-network-association

- [About the TEN Network Association](/docs/governance/ten-network-association/association.md): Introduction and Vision
- [Token Delegates and Delegating](/docs/governance/ten-network-association/delegation.md): When you get involved in the governance of TEN, you can either vote directly on proposals or hand over your voting power to a delegate. The delegation system allows $TEN token holders to take part passively by transferring their voting power to delegates who share their values and who they trust to vote on their behalf in a way which aligns to those values. This page breaks down what delegates do and how delegation works within the governance of TEN.
- [Overview of the TEN Token](/docs/governance/ten-network-association/ten-token.md): The TEN token, known as $TEN, is an ERC-20 governance token that lets you take part in the TEN‚Äôs on-chain decision-making process. The token is created by a smart contract on Ethereum, which is a secure and reliable decentralized blockchain.
- [TEN Improvement Proposals (TIP)](/docs/governance/ten-network-association/tip.md): A TEN Improvement Proposal (TIP) is an essential component of the governance of TEN because it is how participants in the TEN community can have an active role in the evolution of TEN.

### introduction


#### chain-info

TEN Public RPC Endpoints

- [Chain Information](/docs/introduction/chain-info.md): TEN Public RPC Endpoints

#### introduction

TEN is a next-generation Ethereum Layer 2 rollup protocol that introduces data confidentiality, computational privacy, and resistance to Maximal Extractable Value (MEV) by leveraging hardware-based Trusted Execution Environments (TEEs). TEN represents a major step forward in decentralized system design by reintroducing data access controls ‚Äî a foundational feature of Web2 that Web3 largely abandoned in favor of radical transparency.

- [What is TEN Protocol?](/docs/introduction/introduction.md): TEN is a next-generation Ethereum Layer 2 rollup protocol that introduces data confidentiality, computational privacy, and resistance to Maximal Extractable Value (MEV) by leveraging hardware-based Trusted Execution Environments (TEEs). TEN represents a major step forward in decentralized system design by reintroducing data access controls ‚Äî a foundational feature of Web2 that Web3 largely abandoned in favor of radical transparency.

### micar-white-papers


#### trading-whitepaper

Download or view the MiCAR Trading Whitepaper below:

- [MiCAR Trading Whitepaper](/docs/micar-white-papers/trading-whitepaper.md): Download or view the MiCAR Trading Whitepaper below:

### overview

TEN in Web3

- [Overview](/docs/overview.md): TEN in Web3

### release-notes

- [Release Notes](/docs/release-notes.md)

### run-ten-node


#### node-architecture

SGX Enclave and Trusted Execution Environment (TEE)

- [Node Architecture](/docs/run-ten-node/node-architecture.md): SGX Enclave and Trusted Execution Environment (TEE)

#### overview

Running a node on the TEN network involves participating in the network‚Äôs transaction processing, batching, and roll-up mechanisms. As a node operator, you will play a critical role in maintaining the network‚Äôs security, scalability, and efficiency. Understanding the flow of transactions and the mechanics of batches and roll-ups is essential for effectively running a node and contributing to the network‚Äôs operation.

- [Node Overview](/docs/run-ten-node/overview.md): Running a node on the TEN network involves participating in the network‚Äôs transaction processing, batching, and roll-up mechanisms. As a node operator, you will play a critical role in maintaining the network‚Äôs security, scalability, and efficiency. Understanding the flow of transactions and the mechanics of batches and roll-ups is essential for effectively running a node and contributing to the network‚Äôs operation.

#### rewards

As a node operator, your participation is essential in maintaining a secure, reliable, and high-performance network. In recognition of your contributions, TEN has implemented a comprehensive reward structure to incentivize active and consistent engagement in the network‚Äôs testnet phases.

- [Node Rewards](/docs/run-ten-node/rewards.md): As a node operator, your participation is essential in maintaining a secure, reliable, and high-performance network. In recognition of your contributions, TEN has implemented a comprehensive reward structure to incentivize active and consistent engagement in the network‚Äôs testnet phases.

#### running-a-node

This guide provides detailed instructions to set up and manage a TEN Validator Node on Azure using Terraform and Ansible. Due to TEN‚Äôs use of SGX architecture and cloud-specific security assurances, all current deployments are limited to cloud infrastructure to mitigate risks associated with physical attacks. A proof-of-cloud assertion, provided by TEN, certifies the security and reliability of each validator node running in the cloud.

- [Running a TEN Validator Node on Azure](/docs/run-ten-node/running-a-node.md): This guide provides detailed instructions to set up and manage a TEN Validator Node on Azure using Terraform and Ansible. Due to TEN‚Äôs use of SGX architecture and cloud-specific security assurances, all current deployments are limited to cloud infrastructure to mitigate risks associated with physical attacks. A proof-of-cloud assertion, provided by TEN, certifies the security and reliability of each validator node running in the cloud.

### smart-contract-features


#### data-access

Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.

- [Data Access](/docs/smart-contract-features/data-access.md): Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.

#### native-commit-reveal

Every on-chain game developer knows that moves that rely on entropy must be executed in two steps.

- [Native commit-reveal](/docs/smart-contract-features/native-commit-reveal.md): Every on-chain game developer knows that moves that rely on entropy must be executed in two steps.

#### native-entropy

This excellent blog explains the need for native entropy.

- [Native secure entropy](/docs/smart-contract-features/native-entropy.md): This excellent blog explains the need for native entropy.

#### transaction-timestamp

Real-time games require users to make quick decisions, and the outcomes depend on the precise moment in time when the action was made.

- [Precise transaction timestamp](/docs/smart-contract-features/transaction-timestamp.md): Real-time games require users to make quick decisions, and the outcomes depend on the precise moment in time when the action was made.

### write-ten-dapp


#### bridging

The TEN Bridge project aims to facilitate the seamless transfer of assets between the Ethereum blockchain and the TEN blockchain. This documentation provides an overview of the project, its purpose, supported tokens, and usage instructions.

- [Cross-Chain Bridging](/docs/write-ten-dapp/bridging.md): The TEN Bridge project aims to facilitate the seamless transfer of assets between the Ethereum blockchain and the TEN blockchain. This documentation provides an overview of the project, its purpose, supported tokens, and usage instructions.

#### high-level-concepts

Below are the core concepts that make TEN unique while maintaining complete compatibility with existing Ethereum tooling and workflows.

- [High Level Concepts](/docs/write-ten-dapp/high-level-concepts.md): Below are the core concepts that make TEN unique while maintaining complete compatibility with existing Ethereum tooling and workflows.

#### network-setup

Migrating to TEN enables your dApp to leverage ‚Äúprogrammable encryption.‚Äù Below are steps to help you transition smoothly.

- [Network Configuration](/docs/write-ten-dapp/network-setup.md): Migrating to TEN enables your dApp to leverage ‚Äúprogrammable encryption.‚Äù Below are steps to help you transition smoothly.

#### sample-dapps

Below you can view our in-house sample dApps developed to harness the power of TEN.

- [Sample dApps](/docs/write-ten-dapp/sample-dapps.md): Below you can view our in-house sample dApps developed to harness the power of TEN.

#### session-keys

The key feature of Account Abstraction (EIP-4337) is ‚Äúsession keys‚Äù (SKs) through a proxy smart contract.

- [Account Abstraction](/docs/write-ten-dapp/session-keys.md): The key feature of Account Abstraction (EIP-4337) is ‚Äúsession keys‚Äù (SKs) through a proxy smart contract.

#### setup-dev-env

1. Wallet Setup & Configuration

- [Set Up Development Environment](/docs/write-ten-dapp/setup-dev-env.md): 1. Wallet Setup & Configuration

#### testnet

TEN Sepolia is our testnet that replicates the capabilities of the TEN Mainnet network. Linked to the Sepolia testnet, you can authenticate with the testnet TEN gateway, use the TEN faucet, and develop and deploy dApps for testing.

- [Testnet](/docs/write-ten-dapp/testnet.md): TEN Sepolia is our testnet that replicates the capabilities of the TEN Mainnet network. Linked to the Sepolia testnet, you can authenticate with the testnet TEN gateway, use the TEN faucet, and develop and deploy dApps for testing.

#### tutorial

You can follow this tutorial on GitHub that demonstrates how TEN‚Äôs precise timestamping enables sophisticated financial applications requiring exact timing. The combination of privacy, accurate timestamps, and Ethereum compatibility makes TEN ideal for high frequency trading and other time‚Äësensitive financial applications.

- [Tutorial](/docs/write-ten-dapp/tutorial.md): You can follow this tutorial on GitHub that demonstrates how TEN‚Äôs precise timestamping enables sophisticated financial applications requiring exact timing. The combination of privacy, accurate timestamps, and Ethereum compatibility makes TEN ideal for high frequency trading and other time‚Äësensitive financial applications.


---

# Full Documentation Content

## Markdown page example

> You don't need React to write simple standalone pages.

# Markdown page example

You don't need React to write simple standalone pages.


---

## Search the documentation

[Skip to main content](#__docusaurus_skipToContent_fallback)

[![TEN Logo](/img/logo.svg)![TEN Logo](/img/logo-white.svg)](/index.md)

[Documentation](/docs/overview.md)[Blog](https://medium.com/obscuro-labs)

Search

# Search the documentation

Docs

* [Introduction](/docs/overview.md)

Community

* [Discord](https://discord.gg/Zgx2ycH7Xw)
* [Twitter](https://twitter.com/tenprotocol)

More

* [Blog](https://medium.com/obscuro-labs)
* [GitHub](https://github.com/ten-protocol/ten-documentation)

Copyright ¬© 2025 Ten Docs, Inc. Built with Docusaurus.


---

## Governance

## [üìÑÔ∏è<!-- --> <!-- -->Governance](/docs/governance/governance.md)

[TEN's governance is explicit, transparent, and draws inspiration from the experiences of Bitcoin and Ethereum. In a decentralized system, control can be:](/docs/governance/governance.md)


---

## MiCAR White Papers

> MiCAR regulatory whitepapers and documentation

## [üìÑÔ∏è<!-- --> <!-- -->MiCAR Trading Whitepaper](/docs/micar-white-papers/trading-whitepaper.md)

[Download or view the MiCAR Trading Whitepaper below:](/docs/micar-white-papers/trading-whitepaper.md)


---

## Run a TEN node

## [üìÑÔ∏è<!-- --> <!-- -->Node Overview](/docs/run-ten-node/overview.md)

[Running a node on the TEN network involves participating in the network‚Äôs transaction processing, batching, and roll-up mechanisms. As a node operator, you will play a critical role in maintaining the network‚Äôs security, scalability, and efficiency. Understanding the flow of transactions and the mechanics of batches and roll-ups is essential for effectively running a node and contributing to the network‚Äôs operation.](/docs/run-ten-node/overview.md)


---

## Smart Contract Features

## [üìÑÔ∏è<!-- --> <!-- -->Data Access](/docs/smart-contract-features/data-access.md)

[Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.](/docs/smart-contract-features/data-access.md)


---

## TEN Network Association

## [üìÑÔ∏è<!-- --> <!-- -->About the TEN Network Association](/docs/governance/ten-network-association/association.md)

[Introduction and Vision](/docs/governance/ten-network-association/association.md)


---

## Write a TEN dApp

## [üìÑÔ∏è<!-- --> <!-- -->High Level Concepts](/docs/write-ten-dapp/high-level-concepts.md)

[Below are the core concepts that make TEN unique while maintaining complete compatibility with existing Ethereum tooling and workflows.](/docs/write-ten-dapp/high-level-concepts.md)


---

## Governance

> TEN's governance is explicit, transparent, and draws inspiration from the experiences of Bitcoin and Ethereum. In a decentralized system, control can be:

# Governance

TEN's governance is explicit, transparent, and draws inspiration from the experiences of Bitcoin and Ethereum. In a decentralized system, control can be:

* **Explicit**: Exercised by a group through direct signing or voting.
* **Implicit Immutable**: Implemented in an unchangeable protocol.
* **Implicit Mutable**: Implemented in a protocol represented by an open-source, changeable codebase.

## TEN Controls[‚Äã](#ten-controls "Direct link to TEN Controls")

### 1. TEE Attestation Constraints[‚Äã](#1-tee-attestation-constraints "Direct link to 1. TEE Attestation Constraints")

The Attestation Constraints control which software can run inside the Secure Enclave, processing user transactions and creating rollups. Independent security auditors analyze and approve the code. The constraints contain the keys of these auditors, determining which software is permitted.

### 2. Administration Of Ethereum Management Contracts[‚Äã](#2-administration-of-ethereum-management-contracts "Direct link to 2. Administration Of Ethereum Management Contracts")

Ethereum management contracts in TEN may have upgradeable components to address bugs and introduce new features. Upgradeable components imply administrative control over:

* Bridge logic
* Rollup logic
* Attestation logic

### 3. Creating Rollups[‚Äã](#3-creating-rollups "Direct link to 3. Creating Rollups")

TEN Aggregators, running attested software and hardware with a stake, have the power to append to the L2 ledger. However, they cannot choose competing software or create forks.

### 4. Canonical Rollup Chain[‚Äã](#4-canonical-rollup-chain "Direct link to 4. Canonical Rollup Chain")

The canonical chain in TEN is determined by the rules implemented in the attested software run by Aggregators. A valid Secure Enclave will not sign a rollup built on a non-canonical chain, ensuring ledger integrity.

### 5. Slashing The Stake Of Misbehaving Parties[‚Äã](#5-slashing-the-stake-of-misbehaving-parties "Direct link to 5. Slashing The Stake Of Misbehaving Parties")

Aggregators attempting to compromise the ledger's integrity face penalties. Misbehaviors are detected by the protocol, and culprits are penalized through stake slashing.

### 6. Expected Monthly Operational Cost For Nodes[‚Äã](#6-expected-monthly-operational-cost-for-nodes "Direct link to 6. Expected Monthly Operational Cost For Nodes")

TEN's fee structure aims for predictable income for node operators and fees for users. A set value representing the monthly operational cost for each node is crucial for determining fees and balancing decentralization with user costs.


---

## About the TEN Network Association

> Introduction and Vision

# About the TEN Network Association

## Introduction and Vision[‚Äã](#introduction-and-vision "Direct link to Introduction and Vision")

### Mission Statement[‚Äã](#mission-statement "Direct link to Mission Statement")

The TEN Network Association, the Association, aims to push forward the growth and development of the open-source TEN Network software protocol, building a lively and engaged community around it.

### Purpose[‚Äã](#purpose "Direct link to Purpose")

The Association is a not-for-profit organization based in Switzerland, dedicated to promoting, developing, and supporting the TEN software protocol and its ecosystem. The Association‚Äôs goal is to tackle challenges within the Web3 space through decentralized governance and community-driven projects.

## Governance and Structure[‚Äã](#governance-and-structure "Direct link to Governance and Structure")

### Legal Framework[‚Äã](#legal-framework "Direct link to Legal Framework")

The Association operates as a Swiss Association governed by Swiss law. The legal foundation includes the Articles of Association, General Assembly Regulations, Organizational Regulations, and Governance Regulations.

### Organizational Structure[‚Äã](#organizational-structure "Direct link to Organizational Structure")

There are a number of bodies within the Association. New bodies can be created over time.

1. **TEN Governance, or DAO**: participants in the TEN ecosystem who submit proposals for the advancement of TEN.
2. **General Assembly**: the top decision-making body made up of all members.
3. **Board**: manages and oversees the Association's operations.
4. **Subcommittees**: created to handle specific tasks and projects, for example, the administration of grant programs.

### Decision-Making Process[‚Äã](#decision-making-process "Direct link to Decision-Making Process")

Decisions are made through a combination of General Assembly votes and decentralized governance mechanisms using TEN tokens. Each token gives you one vote, and you can delegate your voting rights. You also need to hold the TEN tokens for at least 30 days. This prevents flash loan attacks. Responsible progress of TEN‚Äôs evolution is essential to its long term health and well being. If a proposal is voted in by the DAO but it would be bad for the mission of the TEN Network Association or if a law or regulation would be broken then the Board can step in to assist.

## Projects and Initiatives[‚Äã](#projects-and-initiatives "Direct link to Projects and Initiatives")

### Ongoing Projects[‚Äã](#ongoing-projects "Direct link to Ongoing Projects")

The Association supports a variety of projects aimed at improving TEN and its ecosystem, including software development, community-building, and educational initiatives. The Association also selects specific teams to help develop and enrich the TEN.

### Proposals and Voting[‚Äã](#proposals-and-voting "Direct link to Proposals and Voting")

DAO members can submit proposals for new projects or changes to the protocol. Proposals are reviewed and voted on by participants in the TEN ecosystem.

## Community and Communication[‚Äã](#community-and-communication "Direct link to Community and Communication")

### Communication Channels[‚Äã](#communication-channels "Direct link to Communication Channels")

There are a number of communication channels dedicated to different purposes so all participants in the TEN ecosystem have an opportunity to engage widely with their fellow ecosystem participants.

The Association **[website](https://association.ten.xyz)** is the main hub for information and updates.<br /><!-- -->The Association **[forum](https://forum.ten.xyz)** is specifically focused on discussions on submitted improvement proposal. Improvement proposals will contain a link to the relevent discussion in the forum.<br /><!-- -->You can follow the Association on **[X](https://x.com/tenassociation)** for updates and the latest news.

### Community Guidelines[‚Äã](#community-guidelines "Direct link to Community Guidelines")

We encourage respect, constructive feedback, and collaboration. We have clear guidelines and disciplinary actions for breaches.

## Legal and Compliance Information[‚Äã](#legal-and-compliance-information "Direct link to Legal and Compliance Information")

### Legal Disclaimers[‚Äã](#legal-disclaimers "Direct link to Legal Disclaimers")

Disclaimers are provided about the nature of the Association, risks involved, and legal obligations of members.

### Compliance Information[‚Äã](#compliance-information "Direct link to Compliance Information")

The Association adheres to Swiss laws and regulations, and compliance information is regularly updated and published.

## Feedback and Improvement[‚Äã](#feedback-and-improvement "Direct link to Feedback and Improvement")

### Feedback Mechanisms[‚Äã](#feedback-mechanisms "Direct link to Feedback Mechanisms")

Participants of the TEN ecosystem can provide feedback through the **[TEN Discord server](https://discord.gg/yQfmKeNzNd)**, occasional surveys, and direct communication using the contact details below.

### Continuous Improvement[‚Äã](#continuous-improvement "Direct link to Continuous Improvement")

Processes are in place for continuous improvement based on community feedback, ensuring the Association evolves and adapts to meet its goals effectively.

The Association can be contacted by email: <governance@ten.xyz>

The Association‚Äôs mailing address is:<br /><!-- -->TEN Network Association,<br /><!-- -->c/o MJP Partners AG,<br /><!-- -->Bahnhofstrasse 20,<br /><!-- -->6300 Zug


---

## Token Delegates and Delegating

> When you get involved in the governance of TEN, you can either vote directly on proposals or hand over your voting power to a delegate. The delegation system allows $TEN token holders to take part passively by transferring their voting power to delegates who share their values and who they trust to vote on their behalf in a way which aligns to those values. This page breaks down what delegates do and how delegation works within the governance of TEN.

# Token Delegates and Delegating

When you get involved in the governance of TEN, you can either vote directly on proposals or hand over your voting power to a delegate. The delegation system allows $TEN token holders to take part passively by transferring their voting power to delegates who share their values and who they trust to vote on their behalf in a way which aligns to those values. This page breaks down what delegates do and how delegation works within the governance of TEN.

## What is a delegate?[‚Äã](#what-is-a-delegate "Direct link to What is a delegate?")

A delegate is someone in the TEN community chosen to represent other token holders and vote on their behalf. They are selected by token holders who decide to give their voting power to them. Delegates must stick to the rules set by TEN Network Association and act in the best interest of the token holders they represent.

## Why delegate?[‚Äã](#why-delegate "Direct link to Why delegate?")

Delegation is useful because it allows token holders to be part of the governance of TEN without having to follow every single proposal and vote. By delegating, token holders can let a representative vote on proposals in a way that matches their own views and values.

If you delegate your voting power, you can take it back whenever you want. You might want to do this if there's a proposal you feel strongly about and want to vote on directly.

## How to delegate[‚Äã](#how-to-delegate "Direct link to How to delegate")

The governance of TEN uses Tally to make delegation easy:

1. Connect your Ethereum wallet to Tally and go to the TEN governance page.
2. Click on the "delegate" button.
3. Find the delegate you want to give your voting power to and confirm the delegation by following the prompts on Tally.

With Tally, you can change or cancel your delegation at any time. You can also split your voting power among multiple delegates.


---

## Overview of the TEN Token

> The TEN token, known as $TEN, is an ERC-20 governance token that lets you take part in the TEN‚Äôs on-chain decision-making process. The token is created by a smart contract on Ethereum, which is a secure and reliable decentralized blockchain.

# Overview of the TEN Token

The TEN token, known as $TEN, is an ERC-20 governance token that lets you take part in the TEN‚Äôs on-chain decision-making process. The token is created by a smart contract on Ethereum, which is a secure and reliable decentralized blockchain.

With TEN's governance model, you get to manage both the governance rules laid out in the governance guidelines and the technologies it oversees through the submission of improvement proposals. If you hold TEN tokens you can vote on TEN improvement proposals (TIPs) which influence how TEN operates and evolves. For example, deciding on project grants, updating the validator whitelist for gated TEN networks, and deciding on bug bounties and ecosystem incentives.

When you vote on a TIP, you're using your TEN tokens to show whether you‚Äôre for or against it. The more TEN tokens you have, the more weight your vote carries. This is because the voting system, using smart contracts, is designed to be token-weighted, meaning your vote's power depends on how many tokens are in your wallet.

You can also delegate your TEN tokens to other wallets. So, you can vote with your tokens or someone else‚Äôs if they‚Äôve given you their voting power. This is useful for folks who might not have time to go over proposals regularly. Just keep in mind, you need to have held your TEN tokens for at least 30 days before you can use them to vote. This helps prevent any quick, manipulative flash-loan attacks.

To summarize, the TEN token is a special digital asset that gives you the power to vote on proposals that impact how TEN is governed and the technology it controls. By holding TEN tokens, you get to help shape the future of the TEN ecosystem along with other like-minded participants.


---

## TEN Improvement Proposals (TIP)

> A TEN Improvement Proposal (TIP) is an essential component of the governance of TEN because it is how participants in the TEN community can have an active role in the evolution of TEN.

# TEN Improvement Proposals (TIP)

A TEN Improvement Proposal (TIP) is an essential component of the governance of TEN because it is how participants in the TEN community can have an active role in the evolution of TEN.

TIPs are submitted by anyone holding TEN tokens and who are therefore members of the TEN Governance, or DAO. TIPs are used to modify procedures, install or modify software, update permission whitelists where they exist. Also TIPs include requests for funds or grants and provide guidelines or information to the community.

## TIP Structure[‚Äã](#tip-structure "Direct link to TIP Structure")

The following sections should be completed when creating a TIP to make them transparent, structured and easy to understand. The structure of a TIP follows the SMARTKIT approach:

1. **Summary**: A brief summary of the TIP.
2. **Motivation**: Justification for implementing the TIP.
3. **Alignment**: Explanation of how the TIP aligns with TEN's mission and values.
4. **Risks**: description of any risks of proceeding with the TIP.
5. **Terms**: Definitions of unique, new, or industry-specific terms (optional).
6. **Key Details**: Detailed breakdown of platforms, technologies, and design decisions. Includes alternate designs and related work.
7. **Implementation**: Steps to implement the TIP, including assumptions, resources, type of expertise required and costs breakdown. Legal documentation should be included if relevant.
8. **Timing**: Start date, milestones, and completion dates.

## Lifecycle of a TIP[‚Äã](#lifecycle-of-a-tip "Direct link to Lifecycle of a TIP")

A TIP will go through several steps to help make sure as many members of the TEN community as possible can engage with and review the TIP. Progressing past each step represents levelling-up in the process. Timeframes for each step help encourage reviews to be done in a timely manner.

| Level     | Description                           | Timeframe |
| --------- | ------------------------------------- | --------- |
| 8 (End)   | ‚≠ê TIP Implementation                 | Minutes   |
| 7         | ‚¨ÜÔ∏è Ethereum Finalization Period       | 3 days    |
| 6         | ‚¨ÜÔ∏è TEN to Ethereum Message            | 0.5 day   |
| 5         | ‚¨ÜÔ∏è Reaction Period                    | 3 days    |
| 4         | ‚¨ÜÔ∏è Acknowledge and Confirm            | 3 days    |
| 3         | ‚¨ÜÔ∏è On-chain Vote                      | 14 days   |
| 2         | ‚¨ÜÔ∏è On-chain Voting Preparation        | 3 days    |
| üõë        | Gate                                  |           |
| 1 (Start) | ‚¨ÜÔ∏è Interest Gathering, Off-chain Vote | 14 days   |

### Level 1: Interest Gathering, Off-chain Vote[‚Äã](#level-1-interest-gathering-off-chain-vote "Direct link to Level 1: Interest Gathering, Off-chain Vote")

This first level is a preliminary filter to remove TIPs with low levels of interest or TIPs which will break the rules of the TEN governance system, e.g. are unlawful.

* Submission of TIP on Snapshot with a link to the TEN governance forum. Only holders of TEN tokens can submit a TIP
* Discussion on the TEN governance forum and the opportunity to vote over 14 days to gauge interest. To vote you must hold at least one TEN token for 30 days or more
* A simple majority vote (more than 50%) against the proposal at this stage discourages progressing to level 2

### Level 2: On-chain Voting Preparation[‚Äã](#level-2-on-chain-voting-preparation "Direct link to Level 2: On-chain Voting Preparation")

This second level is the first step towards formalizing the TIP and preparing for the more meaningful vote at the next level.

* Official submission via governance smart contracts on TEN
* Requires a wallet address representing at least 1 TEN token held for at least 30 days
* 3-day discussion period before voter snapshot and voting

### Level 3: On-chain Vote[‚Äã](#level-3-on-chain-vote "Direct link to Level 3: On-chain Vote")

At this third level those who are eligible to vote will do so. There is a minimum threshold of engagement so only genuinely relevant TIPs are progressed.

* On-chain voting by participants of TEN's governance via Tally
* A simple majority vote in favor (more than 50%) plus meeting a minimum threshold of engagement means the TIP will be moved on to level 4 voting. The minimum threshold of engagement is 5% of all TEN tokens in circulation
* A majority vote against the TIP brings the lifecycle to an end. The original submitter is welcome to resubmit the TIP at Level 1 taking on board feedback and comments

### Level 4: Acknowledge and Confirm[‚Äã](#level-4-acknowledge-and-confirm "Direct link to Level 4: Acknowledge and Confirm")

This fourth level is a safety backstop and is particularly important in the early life of TEN. Consider this level to be the training wheels.

* The TEN Governance Board are requested to acknowledge the voting outcome for the TIP
* Confirmation moves the TIP to the next Level

### Level 5: Reaction Period[‚Äã](#level-5-reaction-period "Direct link to Level 5: Reaction Period")

The fifth level recognizes not everyone can be satisfied all of the time therefore individuals have an opportunity to change how they engage with TEN.

* Post-approval 3-day period in which members of the TEN ecosystem can react to the approved TIP by changing how they engage with TEN, for example, withdrawing assets on TEN or deploying changes to smart contracts on TEN.

### Level 6: TEN to Ethereum Message[‚Äã](#level-6-ten-to-ethereum-message "Direct link to Level 6: TEN to Ethereum Message")

The sixth level is an important step so the voting result can be immutably captured on Ethereum mainnet.

* Sending an L2-to-L1 message indicating TIP approval, finalizing on Ethereum mainnet
* A 12 hour period is ample time for the L2-to-L1 message to be finalized by the TEN validators

### Level 7: Ethereum Finalization Period[‚Äã](#level-7-ethereum-finalization-period "Direct link to Level 7: Ethereum Finalization Period")

This level is a safety margin in case there is a transaction in process on Ethereum which would be detrimentally affected by the execution of the TIP.

* 3-day period to finalize in-progress transactions on Ethereum mainnet before implementation

### Level 8: TIP Implementation[‚Äã](#level-8-tip-implementation "Direct link to Level 8: TIP Implementation")

This is the final level where the TIP is fully executed and implemented. Only a future TIP will change the end result of the TIP.

* Final execution of the TIP either on the Ethereum mainnet or via L1-to-L2 transactions

## Additional Waiting Periods[‚Äã](#additional-waiting-periods "Direct link to Additional Waiting Periods")

For breaking changes, additional waiting periods mean stakeholders and partners can prepare for the TIP's changes. These waiting periods give time for members of the ecosystem to react to the TIP and make any necessary changes or updates.

## Conclusion[‚Äã](#conclusion "Direct link to Conclusion")

The TIP process, spanning 8 levels, typically takes 40.5 days from start to finish. The levels have been designed to allow for thorough consideration, discussion, and thoughtful voting. This process aligns proposed changes with TEN's mission and values, allowing stakeholders to prepare for and adapt to new changes.


---

## Chain Information

> TEN Public RPC Endpoints

# Chain Information

## TEN Public RPC Endpoints[‚Äã](#ten-public-rpc-endpoints "Direct link to TEN Public RPC Endpoints")

caution

* TEN Protocol RPC endpoints support standard Ethereum JSON-RPC methods with additional privacy features
* All transactions are encrypted by default - use TEN-compatible wallets and tools
* View the [faucet](https://faucet.ten.xyz/) for testnet tokens

This section provides an overview of the available public RPC endpoints for TEN Protocol networks and necessary details to interact with them.

| Name                | RPC Url(s)                 | Chain ID | Block explorer                         | Underlying chain | Gateway                             | Bridge                                    | Faucet                            |
| ------------------- | -------------------------- | -------- | -------------------------------------- | ---------------- | ----------------------------------- | ----------------------------------------- | --------------------------------- |
| TEN Mainnet         | `https://rpc.ten.xyz/`     | `443`    | [TENscan](https://tenscan.io/)         | Ethereum         | [Gateway](https://gateway.ten.xyz/) | [Bridge](https://bridge.ten.xyz/)         | [Faucet](https://faucet.ten.xyz/) |
| TEN Sepolia Testnet | `https://testnet.ten.xyz/` | `8443`   | [TENscan](https://testnet.tenscan.io/) | Ethereum Sepolia | [Gateway](https://testnet.ten.xyz/) | [Bridge](https://testnet.bridge.ten.xyz/) | [Faucet](https://faucet.ten.xyz/) |

More RPC endpoints

Additional TEN Protocol RPC endpoints and infrastructure providers will be listed here as they become available.

# JSON-RPC API

TEN offers compatibility with a subset of Ethereum's [JSON-RPC API](https://ethereum.org/en/developers/docs/apis/json-rpc/). This document outlines the supported JSON-RPC API methods.

## Supported Methods[‚Äã](#supported-methods "Direct link to Supported Methods")

TEN nodes cater to the following JSON-RPC API methods, accessible via both HTTP and websockets:

* `eth_blockNumber`
* `eth_call`
* `eth_chainId`
* `eth_estimateGas`
* `eth_gasPrice`
* `eth_getBalance`
* `eth_getBlockByHash`
* `eth_getBlockByNumber`
* `eth_getCode`
* `eth_getLogs`
* `eth_getTransactionByHash`
* `eth_getTransactionCount`
* `eth_getTransactionReceipt`
* `eth_sendRawTransaction`

## Websocket Subscriptions[‚Äã](#websocket-subscriptions "Direct link to Websocket Subscriptions")

For websocket connections, additional API methods include:

* `eth_subscribe`
* `eth_unsubscribe`

Currently, the sole supported subscription type is `logs`.

## Network Configuration[‚Äã](#network-configuration "Direct link to Network Configuration")

### TEN Sepolia Testnet[‚Äã](#ten-sepolia-testnet "Direct link to TEN Sepolia Testnet")

To add TEN Sepolia Testnet to your wallet, use the following configuration:

```
{
  "chainId": "0x20FB",
  "chainName": "TEN Sepolia Testnet",
  "rpcUrls": ["https://testnet.ten.xyz/v1/"],
  "nativeCurrency": {
    "name": "Ether",
    "symbol": "ETH",
    "decimals": 18
  },
  "blockExplorerUrls": ["https://testnet.tenscan.io/"]
}
```


---

## What is TEN Protocol?

> TEN is a next-generation Ethereum Layer 2 rollup protocol that introduces data confidentiality, computational privacy, and resistance to Maximal Extractable Value (MEV) by leveraging hardware-based Trusted Execution Environments (TEEs). TEN represents a major step forward in decentralized system design by reintroducing data access controls ‚Äî a foundational feature of Web2 that Web3 largely abandoned in favor of radical transparency.

# What is TEN Protocol?

TEN is a next-generation Ethereum Layer 2 rollup protocol that introduces data confidentiality, computational privacy, and resistance to Maximal Extractable Value (MEV) by leveraging hardware-based Trusted Execution Environments (TEEs). TEN represents a major step forward in decentralized system design by reintroducing **data access controls** ‚Äî a foundational feature of Web2 that Web3 largely abandoned in favor of radical transparency.

## The Web3 Privacy Problem[‚Äã](#the-web3-privacy-problem "Direct link to The Web3 Privacy Problem")

Public blockchains have validated the promise of programmable value, but exposed a critical flaw: the complete absence of data access control. Transparency, once celebrated as a virtue, has become a liability. On-chain activity today remains fully public ‚Äî every balance, transaction, strategy, and piece of logic is visible to everyone, including competitors, adversaries, and MEV bots.

If you analyze any successful digital application ‚Äî Netflix, WhatsApp, Spotify, banking apps, even mobile games ‚Äî they all rely on access control. Not just for privacy, but to function. Smart contracts today can define who can write data, but they cannot restrict who can read it. This fundamental limitation makes it nearly impossible to build viable real-world applications in Web3 beyond speculation.

## TEN's Solution: Smart Transparency[‚Äã](#tens-solution-smart-transparency "Direct link to TEN's Solution: Smart Transparency")

TEN introduces **Smart Transparency** ‚Äî a paradigm where smart contracts not only enforce rules of computation, but also enforce rules of data access. By integrating [programmable encryption](https://medium.com/obscuro-labs/web3-needs-access-control-9a80719eec4a), TEEs, and an Ethereum-compatible execution environment, TEN enables encrypted, autonomous, and composable smart contracts that preserve privacy without sacrificing decentralization or composability.

### Core Architecture[‚Äã](#core-architecture "Direct link to Core Architecture")

**Encrypted Execution**: All transactions and internal state of application contracts remain encrypted and hidden, providing a credible solution to MEV while maintaining EVM compatibility for easy migration of existing contracts.

**Trustless Design**: TEN leverages TEEs for privacy but not for integrity. If a TEE is compromised or a manufacturer behaves maliciously, the system gracefully degrades into a transparent blockchain, preserving ledger integrity while forfeiting privacy.

**Ethereum Layer 1**: TEN uses Ethereum as a base layer for security and data availability while enabling lower transaction costs similar to other Layer 2 networks, with quick finality synchronized to L1 block cadence.

## Key Differentiators from Transparent Chains[‚Äã](#key-differentiators-from-transparent-chains "Direct link to Key Differentiators from Transparent Chains")

| Feature                                    | Transparent Chains                        | TEN Protocol                                             |
| ------------------------------------------ | ----------------------------------------- | -------------------------------------------------------- |
| **Data Access**                            | All data public                           | Programmable access control                              |
| **MEV Protection**                         | Limited solutions                         | Built-in confidentiality                                 |
| **Smart Contract State**                   | Fully visible                             | Encrypted with selective disclosure                      |
| **Transaction Privacy**                    | Public by default                         | Private by default                                       |
| **Compliance**                             | Difficult                                 | Time-delayed revelation for deterrence                   |
| **Account-based smart contract execution** | Account model with public state and calls | Account model, EVM-compatible, encrypted state and calls |
| **Decentralised**                          | Decentralised consensus                   | Sequencer and decentralised validators                   |

## Addressing Key Challenges[‚Äã](#addressing-key-challenges "Direct link to Addressing Key Challenges")

**Hardware Trust**: TEN's trust model doesn't require perpetual belief in any single hardware vendor. The protocol uses Ethereum's security combined with game theory to detect and correct eventual TEE compromises.

**Usability**: The system implements flexible policies for delayed transaction revelation, balancing privacy needs with regulatory compliance and illegal activity deterrence.

**MEV Prevention**: Beyond hiding transactions, TEN introduces delays at critical moments to prevent aggregators from performing replay-attacks and exploiting side-channels.

## Unlocking New Applications[‚Äã](#unlocking-new-applications "Direct link to Unlocking New Applications")

TEN's confidential rollup architecture enables previously impossible on-chain applications:

* **Confidential DeFi**: Dark pools, private lending, MEV-resistant trading
* **Private Gaming**: Poker, strategy games with hidden information
* **Autonomous AI Agents**: Protected algorithms and private coordination
* **Enterprise Solutions**: Confidential auctions, private supply chains
* **TEE-Stablecoins**: Reserve-backed with provable but confidential attestation

## Whitepaper & Blog Links[‚Äã](#whitepaper--blog-links "Direct link to Whitepaper & Blog Links")

* [TEN Protocol Whitepaper](https://github.com/ten-protocol/ten-whitepaper/blob/main/whitepaper.md)
* [SGX Demystified](https://medium.com/obscuro-labs/intel-sgx-demystified-757a242682a3)
* [Smart Transparency](https://medium.com/obscuro-labs/web3-needs-access-control-9a80719eec4a)
* [Securing Randomness](https://medium.com/obscuro-labs/against-all-odds-securing-randomness-on-the-blockchain-4c15587a39a8)
* [High-Level Explanation](https://medium.com/obscuro-labs/ten-in-a-nutshell-for-devs-874666910f65)
* [iGaming Features](https://medium.com/@tudor.malene/the-ideal-gaming-chain-bb5674202ec2)


---

## MiCAR Trading Whitepaper

> Download or view the MiCAR Trading Whitepaper below:

# MiCAR Trading Whitepaper

Download or view the MiCAR Trading Whitepaper below:

## Download PDF[‚Äã](#download-pdf "Direct link to Download PDF")

[Download MiCAR Trading Whitepaper (PDF)](/assets/files/micar-whitepaper-672ce6aa9f9198df41ed3918bfcb2832.pdf.md)

## Embedded Viewer[‚Äã](#embedded-viewer "Direct link to Embedded Viewer")

If the embedded viewer doesn't work in your browser, please use the download link above.


---

## Overview

> TEN in Web3

![TEN in Web3](/assets/images/overview-banner-5802f2f2deee39c331f1f9002e4838b2.png)

*The full Litepaper is available to view [here](https://ten.xyz/litepaper).*

# Overview

**TEN Protocol** is a next-generation, Ethereum-compatible Layer-2 rollup that brings **programmable privacy**, **AI-native design**, and **shared encrypted state** to smart contracts. By combining **Trusted Execution Environments (TEEs)** with encrypted EVM transactions, TEN introduces a new primitive: the **confidential rollup** ‚Äî enabling developers to build trustless applications with data access controls, private logic, and autonomous agents.

TEN reclaims the critical Web2 feature Web3 left behind: **privacy with permissioning**. This unlocks entire categories of applications previously impossible on-chain ‚Äî like private messaging, hidden game logic, confidential trading strategies, and collaborative AI agents.

***

## Core Technology[‚Äã](#core-technology "Direct link to Core Technology")

* **Confidential Rollups**<br /><!-- -->A new rollup architecture that merges the scalability of optimistic rollups with privacy guarantees.

* **Encrypted EVM**<br /><!-- -->Smart contracts execute inside TEEs, shielding logic, inputs, and state from all observers ‚Äî even node operators.

* **Encrypted Transactions**<br /><!-- -->Wallets encrypt transaction data before submission. Decryption occurs only under programmable rules.

* **Trusted Execution Environments (TEEs)**<br /><!-- -->Hardware-isolated enclaves trusted by hyperscalers, banks, and AI leaders ‚Äî now used to run encrypted smart contracts and agents on-chain.

* **Smart Transparency**<br /><!-- -->Developers control what data is public, private, or time-delayed ‚Äî supporting selective disclosure and compliance.

***

## Data Revelation[‚Äã](#data-revelation "Direct link to Data Revelation")

Confidentiality on your terms:

* Programmable disclosure (time-based or conditional)
* Full control over visibility windows
* Optional perpetual privacy via governance

***


---

## Release Notes

# Release Notes

Loading‚Ä¶


---

## Node Architecture

> SGX Enclave and Trusted Execution Environment (TEE)

# Node Architecture

## SGX Enclave and Trusted Execution Environment (TEE)[‚Äã](#sgx-enclave-and-trusted-execution-environment-tee "Direct link to SGX Enclave and Trusted Execution Environment (TEE)")

The TEN network leverages Intel Software Guard Extensions (SGX) enclaves to create a secure and trusted execution environment (TEE) for processing transactions and executing smart contracts. SGX enclaves are isolated regions of memory that are encrypted and protected from unauthorised access, ensuring that sensitive data remains confidential and secure. Every transaction and smart contract execution on the TEN network is processed within an SGX enclave, guaranteeing the integrity and confidentiality of the data involved. Additionally, SGX enclaves provide hardware-based attestation, enabling nodes to verify the authenticity of each other and establish trust within the network.

## Node Composition[‚Äã](#node-composition "Direct link to Node Composition")

![TEN Validator Composition](/assets/images/ten-validator-composition-06841f0021b4acb068aff3f1318eb9d3.png)

The TEN Validator is composed of the following components:

## Host and Enclave Architecture[‚Äã](#host-and-enclave-architecture "Direct link to Host and Enclave Architecture")

#### Process Separation[‚Äã](#process-separation "Direct link to Process Separation")

* Separate OS processes for Host and Enclave
* Communication via gRPC
* Enclave managed by independent supervisor

#### Security Considerations[‚Äã](#security-considerations "Direct link to Security Considerations")

* Minimized TCB (Trusted Computing Base)
* Reduced attestation frequency

### Host Component Responsibilities[‚Äã](#host-component-responsibilities "Direct link to Host Component Responsibilities")

* External request handling
* L1/L2 network synchronization
* Secret management and rollup publishing
* Peer node communication
* High-availability management

### Enclave Components and Responsibilities[‚Äã](#enclave-components-and-responsibilities "Direct link to Enclave Components and Responsibilities")

* Transaction validation and execution
* Smart contract computation
* Cryptographic operations and key management
* State management and confidential data processing
* Attestation generation and verification
* Secure random number generation
* Batch processing and sequencing

## Deployment Containerization[‚Äã](#deployment-containerization "Direct link to Deployment Containerization")

There are four deployment containers on a TEN Validator node:

* **Host**: The host component is responsible for external communications and network operations.
* **HostDB/Postgres**: Postgres is used to store the validator's host state.
* **Enclave**: The enclave component is responsible for sensitive computations and data processing (SGX).
* **EnclaveDB/Edgeless**: Edgeless is used to store the validator's enclave state (SGX).

Running a TEN validator will automatically deploy these containers.


---

## Node Overview

> Running a node on the TEN network involves participating in the network‚Äôs transaction processing, batching, and roll-up mechanisms. As a node operator, you will play a critical role in maintaining the network‚Äôs security, scalability, and efficiency. Understanding the flow of transactions and the mechanics of batches and roll-ups is essential for effectively running a node and contributing to the network‚Äôs operation.

# Node Overview

Running a node on the TEN network involves participating in the network‚Äôs transaction processing, batching, and roll-up mechanisms. As a node operator, you will play a critical role in maintaining the network‚Äôs security, scalability, and efficiency. Understanding the flow of transactions and the mechanics of batches and roll-ups is essential for effectively running a node and contributing to the network‚Äôs operation.

## Transaction Flow (TX)[‚Äã](#transaction-flow-tx "Direct link to Transaction Flow (TX)")

![TEN Validator Flow](/assets/images/ten-validator-flow-726be10515f8ffa9b9ec945810682e8d.png)

### 1. Transactions[‚Äã](#1-transactions "Direct link to 1. Transactions")

Transactions are the fundamental operations executed on the TEN network, representing actions such as transferring value, interacting with smart contracts, or executing other network functions. Each transaction serves as a discrete unit of activity, altering the state of the network based on its payload.

### 2. Batches[‚Äã](#2-batches "Direct link to 2. Batches")

Batches consist of multiple transactions grouped together on the TEN network, functioning similarly to blocks on the Ethereum network. By aggregating transactions into batches, the network enhances throughput and lowers latency, optimizing resource usage and improving overall efficiency.

### 3. Roll-ups[‚Äã](#3-roll-ups "Direct link to 3. Roll-ups")

Roll-ups are a layer 2 scaling mechanism employed by the TEN network to securely aggregate and process transactions off-chain, before submitting a compressed version of these transactions to the Ethereum mainnet (Layer 1) for finalization. This approach significantly boosts throughput and reduces latency while maintaining the security guarantees of the Ethereum network.

## Gateway[‚Äã](#gateway "Direct link to Gateway")

The TEN Gateway is a network managed service and load balancer that routes transactions to the appropriate TEN validator nodes. It is responsible for securely encrypting and decrypting transactions, ensuring that sensitive data remains confidential throughout the transaction process. Validators interact with the Gateway to receive transactions, process them, and submit them to the Sequencer for batching and roll-up.

## Node Types[‚Äã](#node-types "Direct link to Node Types")

There are two types of nodes in the TEN network: Sequencers and Validators. They use the same software but have different roles and responsibilities. As a node operator you will be running a Validator node, but it is important to understand the role of Sequencers in the network.

### Sequencer[‚Äã](#sequencer "Direct link to Sequencer")

The TEN Sequencer is a central node that is responsible for ordering transactions, generating new batches, and creating roll-ups on the TEN network. It is the only node that can create new batches and is responsible for broadcasting these to the network, as well as submitting them to the Ethereum mainnet via roll-up.

### Validator[‚Äã](#validator "Direct link to Validator")

A TEN Validator is decentralized node that participates in the TEN network by processing transactions, validating transactions and batches against Ethereum L1 roll-ups, and providing data availability. The participation of multiple validators ensures the network‚Äôs security and integrity.


---

## Node Rewards

> As a node operator, your participation is essential in maintaining a secure, reliable, and high-performance network. In recognition of your contributions, TEN has implemented a comprehensive reward structure to incentivize active and consistent engagement in the network‚Äôs testnet phases.

# Node Rewards

As a node operator, your participation is essential in maintaining a secure, reliable, and high-performance network. In recognition of your contributions, TEN has implemented a comprehensive reward structure to incentivize active and consistent engagement in the network‚Äôs testnet phases.

***

## Program Overview[‚Äã](#program-overview "Direct link to Program Overview")

TEN is an encrypted Layer 2 network built on Ethereum, designed by the team behind Corda. TEN offers a highly scalable and private environment for Web3 applications,including AI, tokenizing real-world assets (RWA), enabling decentralized financial solutions (DeFi) and on-chain games.

### Objective[‚Äã](#objective "Direct link to Objective")

TEN‚Äôs incentivized testnet rewards participants‚Äîincluding node operators, developers, and users‚Äîwho actively contribute to testing and improving the network. Node operators play a vital role in decentralizing TEN and ensuring robust node operations, and they are rewarded for maintaining network health, stability, and performance.

***

## Node Operator Rewards Structure[‚Äã](#node-operator-rewards-structure "Direct link to Node Operator Rewards Structure")

TEN has allocated **22,500,000 TEN** (representing 2.25% of the total token supply) to incentivize contributions across the community, including node operations.

### Rewards Overview[‚Äã](#rewards-overview "Direct link to Rewards Overview")

1. **Staking Requirements**: Node operators do not need an initial stake to participate in the testnet (however, a minimum of 50,000 TEN tokens will be required for staking on Mainnet).
2. **ETH-Based Compensation**: Node operators receive rewards paid in **ETH** to help cover hosting costs and encourage active participation.
3. **Delegated Staking Model**: Community members can delegate their TEN tokens to node operators, broadening community involvement and fostering a more decentralized ecosystem.

### Performance-Based Rewards[‚Äã](#performance-based-rewards "Direct link to Performance-Based Rewards")

Performance-based rewards are structured to motivate the consistent and high-quality performance of nodes, as follows:

* **Top 10% Performers**: The highest 10% of node operators, ranked by performance and uptime, will earn the top reward bracket. Top performers will receive a reward equivalent to the minimum mainnet staking requirement and will be offered priority access to participate in the mainnet launch.
* **Remaining Participants**: Node operators outside the top 10% but in the top 20% will also receive a reward based on their contributions and performance.

### Participation-Based Rewards[‚Äã](#participation-based-rewards "Direct link to Participation-Based Rewards")

Node operators who meet minimum participation requirements but do not rank in the top 20% will still receive a reward. These rewards aim to foster inclusivity and recognize the contributions of all node operators.

***

## Testnet Phases & Participation[‚Äã](#testnet-phases--participation "Direct link to Testnet Phases & Participation")

The incentivized testnet is split into three phases, each lasting approximately **6-8 weeks**, followed by a short intermission between phases. The phases are designed to test and validate different aspects of the network:

1. **Phase 1**: Focus on onboarding developers and user quests aimed at network resilience.
2. **Phase 2**: Dedicated to expanding node operations and enhancing network decentralization.
3. **Phase 3**: Final phase with an emphasis on testing newly deployed dApps and security-focused initiatives.

### Eligibility[‚Äã](#eligibility "Direct link to Eligibility")

* **Application**: Node operators can apply via the [Validator Application Form](https://cform.coinlist.co/forms/56274a78-8291-4899-bee1-a68ecbc5b2b8).

* **Selection**: Applications are prioritized based on node management experience and community commitment, with selected participants notified by email.

  \* Jurisdictional Limitations will be applied.

## Additional Information[‚Äã](#additional-information "Direct link to Additional Information")

* **Updates and Notifications**: Important updates will be shared via the **TEN Discord testnet channel** and by email for selected participants.
* **Documentation**: Technical documents and guides are available on TEN‚Äôs official documentation site, with more added throughout the testnet phases.

### Reward Distribution[‚Äã](#reward-distribution "Direct link to Reward Distribution")

All rewards will be distributed after the mainnet launch, following the tokenomics vesting schedule outlined in the official TEN whitepaper.

***

This Node Rewards program aims to build a community-driven network powered by participants' shared efforts and contributions. By rewarding commitment and performance, TEN is cultivating a stable, high-performance Layer 2 ecosystem that is decentralized, secure, and inclusive.

***

For further queries, please reach out via our **[Discord channel](https://discord.gg/tenprotocol)** or reach out on to **[@TENprotocol](https://twitter.com/tenprotocol)** on X.


---

## Running a TEN Validator Node on Azure

> This guide provides detailed instructions to set up and manage a TEN Validator Node on Azure using Terraform and Ansible. Due to TEN‚Äôs use of SGX architecture and cloud-specific security assurances, all current deployments are limited to cloud infrastructure to mitigate risks associated with physical attacks. A proof-of-cloud assertion, provided by TEN, certifies the security and reliability of each validator node running in the cloud.

# Running a TEN Validator Node on Azure

This guide provides detailed instructions to set up and manage a TEN Validator Node on Azure using Terraform and Ansible. Due to TEN‚Äôs use of SGX architecture and cloud-specific security assurances, all current deployments are limited to cloud infrastructure to mitigate risks associated with physical attacks. A proof-of-cloud assertion, provided by TEN, certifies the security and reliability of each validator node running in the cloud.

***

## Overview[‚Äã](#overview "Direct link to Overview")

The deployment process leverages **Terraform** for Azure infrastructure provisioning and **Ansible** for configuring the Validator Node. By following this guide, you‚Äôll set up a secure, compliant environment that meets TEN‚Äôs standards for validator operations.

* **Terraform**: Automates the creation of Azure resources for a TEN Validator Node.
* **Ansible**: Configures and deploys node software on the provisioned infrastructure.

***

## Requirements[‚Äã](#requirements "Direct link to Requirements")

Before starting, ensure the following dependencies are installed on your local machine:

* [**Terraform**](https://www.terraform.io/downloads.html) (version >= 0.12)
  <!-- -->
  * [Terraform Installation Guide](https://learn.hashicorp.com/tutorials/terraform/install-cli)

* [**Ansible**](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)

  * [Ansible Installation guide](https://docs.ansible.com/ansible/latest/installation_guide/intro_installation.html)
  * **Required Ansible Collections**: Install with:
    <!-- -->
    ```
    ansible-galaxy collection install community.docker community.crypto
    ```

* [**Azure CLI**](https://docs.microsoft.com/en-us/cli/azure/install-azure-cli): For authenticating and managing Azure resources.

* [**Docker**](https://docs.docker.com/get-docker/): Required for node deployment.

* [**Docker Compose**](https://docs.docker.com/compose/install/): Used for managing containerized services.

* [**Git**](https://git-scm.com/downloads): For repository cloning and version control.

***

## Clone the TEN Validator Repository[‚Äã](#clone-the-ten-validator-repository "Direct link to Clone the TEN Validator Repository")

```
git clone https://github.com/ten-protocol/ten-validator.git
cd ten-validator
```

## Azure Setup Instructions (Terraform)[‚Äã](#azure-setup-instructions-terraform "Direct link to Azure Setup Instructions (Terraform)")

### Step 1: Authenticate and Configure Azure[‚Äã](#step-1-authenticate-and-configure-azure "Direct link to Step 1: Authenticate and Configure Azure")

1. **Log into Azure**:
   <!-- -->
   ```
   az login
   ```
2. Set Your Azure Subscription: Specify the Azure subscription for deploying the resources:
   <!-- -->
   ```
   az account set --subscription <your-subscription-id>
   ```

### Step 2: Configure Terraform Variables (optional)[‚Äã](#step-2-configure-terraform-variables-optional "Direct link to Step 2: Configure Terraform Variables (optional)")

```
cp terraform.tfvars.example terraform.tfvars
```

### Step 3: Deploy the Terraform Script[‚Äã](#step-3-deploy-the-terraform-script "Direct link to Step 3: Deploy the Terraform Script")

```
terraform init
terraform apply
```

### Step 4: Access the Validator Node (Optional)[‚Äã](#step-4-access-the-validator-node-optional "Direct link to Step 4: Access the Validator Node (Optional)")

1. `chmod +x get-key.sh ./get-key.sh`
2. `ssh -i <path-to-key> <username>@<public-ip>`

## TEN Validator Setup Instructions (Ansible)[‚Äã](#ten-validator-setup-instructions-ansible "Direct link to TEN Validator Setup Instructions (Ansible)")

1. Network Configuration: Node network settings are located in `ansible/files/network_vars.yml`. These settings are typically not changed and are specific to the L2 network. One will be provided by the TEN team for ITN (testnet) and another for mainnet.

2. Run the Installation Script: Use Ansible to configure and deploy the TEN Validator Node:

   ```
   chmod +x install-ten.sh
   ./install-ten.sh
   ```

   During deployment, you will be prompted to enter:

   * Host ID: Public key of the validator node wallet

   * Private Key: Private key of the validator node wallet

   * Host Public P2P Address: Public IP or DNS of the node

   * SSH Details: Username and key path (or password if applicable)

   * L1 WS URL: WebSocket URL for the Layer 1 node (e.g., Infura)

   * Postgres DB Host: Leave blank to provision a new database

   Note: If Terraform provisioned the VM, default values are often applicable‚Äîjust press Enter to accept.

## Managing the Validator Node[‚Äã](#managing-the-validator-node "Direct link to Managing the Validator Node")

Coming soon! (monitoring, backups, tear down, etc.)


---

## Data Access

> Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.

# Data Access

Solidity encapsulates "private" state variables in a way that prevents them from being accessed by other contracts.

However, private variables are readable externally via [getStorageAt](https://docs.alchemy.com/reference/eth-getstorageat), meaning contracts can't truly have secrets.

TEN overcomes this limitation by offering "Data Access Control" primitives.

To achieve this, we had to:

1. Run the Ethereum Virtual Machine inside a Trusted Execution Environment (TEE) and store the state in encrypted storage. This prevents the node operator from accessing the data.
2. Disable the `getStorageAt` method, so now contracts can have secrets (as long as the `private` state variables are not exposed via public view functions). This prevents anyone with RPC access to the node from reading the data.
3. Authenticate "view function calls" so that the smart contract knows who is calling the view function. Without this feature there is no "Data Access **Control**", because the dApp developer can't write access control logic.
4. Event logs are another way to expose data from a contract to the outside world. A practical platform needs a way to configure who can read the various event logs.
5. Control access to the "Transaction Receipts", which contain the logs and status of the transaction.

## Data Access Control Rules[‚Äã](#data-access-control-rules "Direct link to Data Access Control Rules")

Here, we'll list the platform rules. The examples below will showcase how exactly to use these rules in practice.

* Any contract can be configured to be "transparent" or "private". By default, it is "private", which means the internal storage is not accessible. "Transparent" contracts behave exactly like Ethereum.

* Any RPC call accessing data like: `eth_call`, `eth_estimateGas`, `eth_getTransactionReceipt`, `eth_logs`, must be signed by a [viewing key (VK)](/docs/write-ten-dapp/high-level-concepts.md#ten-gateway). The VK itself must be signed by the main account. (Note that this is behind the scenes.)

* Event log visibility is configurable. Each event log can be visible to one or multiple of the topics (indexed fields), and the sender of the transaction, only if the topic is the `address` of an "Externally owned Account" (EOA). The event log can also be configured to be "public" - visible to everyone.

* When there is no configuration, the default event log visibility is:

  <!-- -->

  * Rule 1: Event logs that contain EOAs as topics are only visible to those EOAs.
  * Rule 2: Event logs that don't contain any EOA are visible to everyone.

* As a general rule, transaction receipts are visible to:

  <!-- -->

  * anyone who can access at least one event log emitted by that transaction,
  * the sender of the transaction, and
  * everyone, if the transaction called a transparent contract.

* `eth_getStorageAt` can be called on "transparent" contracts.

## Data Access Control Example[‚Äã](#data-access-control-example "Direct link to Data Access Control Example")

Let's illustrate with a basic storage dApp example where users can store and retrieve a number.

At every step, we'll add a new feature and explain the difference between `TEN` and `Ethereum`.

### Step 1: Basic contract with a Public Variable[‚Äã](#step-1-basic-contract-with-a-public-variable "Direct link to Step 1: Basic contract with a Public Variable")

#### Code[‚Äã](#code "Direct link to Code")

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

contract StorageExample {
    mapping(address => uint256) public storedValues;

    function storeValue(uint256 value) public {
        storedValues[tx.origin] = value;
    }
}
```

#### Explanation[‚Äã](#explanation "Direct link to Explanation")

In this step, we created a public variable `storedValues` that maps the provided value to the address of the user who called the `storeValue` function.

Because the variable is public, Solidity will provide a default public getter for it.

Since there are no data access restrictions, on both Ethereum and TEN, everyone will be able to read the values of all users by just calling the default public getter.

### Step 2: Converting to a Private Variable with an explicit Getter Function[‚Äã](#step-2-converting-to-a-private-variable-with-an-explicit-getter-function "Direct link to Step 2: Converting to a Private Variable with an explicit Getter Function")

#### Code[‚Äã](#code-1 "Direct link to Code")

```
contract StorageExample {
    mapping(address => uint256) private _storedValues;

    function storeValue(uint256 value) public {
        _storedValues[tx.origin] = value;
    }
    
    function getValue(address account) public view returns (uint256) {
        return _storedValues[account];
    }
}
```

#### Explanation[‚Äã](#explanation-1 "Direct link to Explanation")

The `storedValues` variable is now private, and we added a basic `getValue` function for users to retrieve their value.

On both Ethereum and TEN, anyone can call `getValue` to retrieve any value.<br /><!-- -->On Ethereum, `_storedValues` can also be accessed directly with `getStorageAt`

### Step 3: Data Access Control[‚Äã](#step-3-data-access-control "Direct link to Step 3: Data Access Control")

In this step, we'll add restrictions so users can only access their own data.

#### Code[‚Äã](#code-2 "Direct link to Code")

```
contract StorageExample {
    mapping(address => uint256) private _storedValues;

    function storeValue(uint256 value) public {
        _storedValues[tx.origin] = value;
    }

    function getValue(address account) public view returns (uint256) {
        require(tx.origin == account, "Not authorised!");
        return _storedValues[account];
    }
}
```

#### Explanation[‚Äã](#explanation-2 "Direct link to Explanation")

The key line is: `require(tx.origin == account, "Not authorised!");`, which ensures that the caller of the view function is the owner of the data.

**When deployed on TEN, this code guarantees that all users can only access their own values, and nobody can read the `_storedValues`.**

On Ethereum, the `tx.origin` is not authenticated, so the check above is not effective and `eth_getStorageAt` is available.

### Step 4: Emitting Events - Default Visibility[‚Äã](#step-4-emitting-events---default-visibility "Direct link to Step 4: Emitting Events - Default Visibility")

Event logs notify UIs about state changes in smart contracts.

To improve our smart contract, we‚Äôll emit an event when a user stores a value and milestone events when a specific size threshold is met.

#### Code[‚Äã](#code-3 "Direct link to Code")

```
contract StorageExample {
    mapping(address => uint256) private _storedValues;
    uint256 private totalCalls = 0;

    event DataChanged(address indexed account, uint256 newValue);
    event MilestoneReached(uint256 noStoredValues);

    function storeValue(uint256 value) public {
        _storedValues[tx.origin] = value;
        emit DataChanged(tx.origin, value);
        totalCalls++;
        if (totalCalls % 1000 == 0) {
            emit MilestoneReached(totalCalls);
        }
    }

    function getValue(address account) public view returns (uint256) {
        require(tx.origin == account, "Not authorised!");
        return _storedValues[account];
    }
}
```

#### Explanation[‚Äã](#explanation-3 "Direct link to Explanation")

Notice how we defined the two events: `DataChanged` and `MilestoneReached`, and are emitting them in the `storeValue` function.

In Ethereum, everyone can query and subscribe to these events. If this was possible on TEN, it would completely break the functionality because you can see all the secret values.

Notice how in this version, we have no configuration for event log visibility, so we are relying on the default rules:

* Rule 1: Event logs that contain ("Externally owned Account") EOAs as indexed fields (topics) are only visible to those EOAs.
* Rule 2: Event logs that don't contain any EOA are visible to everyone.

In our case, the default rules ensure that:

* `DataChanged` is visible only to the address that is storing the value.
* `MilestoneReached` is publicly visible.

### Step 5: Customising Event Visibility[‚Äã](#step-5-customising-event-visibility "Direct link to Step 5: Customising Event Visibility")

The default visibility rules are a good starting point, but complex dApps require greater flexibility.

TEN gives you explicit control over event visibility.

#### Code[‚Äã](#code-4 "Direct link to Code")

```

// when implementing this interface, the platform will configure the visibility rules
interface ContractTransparencyConfig {
    enum Field { TOPIC1, TOPIC2, TOPIC3, SENDER, EVERYONE }
    enum ContractCfg { TRANSPARENT, PRIVATE }

    struct EventLogConfig {
        bytes32 eventSignature;
        Field[] visibleTo;
    }

    struct VisibilityConfig {
        ContractCfg contractCfg;
        EventLogConfig[] eventLogConfigs;
    }

    function visibilityRules() external pure returns (VisibilityConfig memory);
}

contract StorageExample is ContractTransparencyConfig {
    mapping(address => uint256) private _storedValues;
    uint256 private totalCalls = 0;

    event DataChanged(address indexed account, uint256 newValue);
    event MilestoneReached(uint256 noStoredValues);

    function storeValue(uint256 value) public {
        _storedValues[tx.origin] = value;
        emit DataChanged(tx.origin, value);
        totalCalls++;
        if (totalCalls % 1000 == 0) {
            emit MilestoneReached(totalCalls);
        }
    }

    function getValue(address account) public view returns (uint256) {
        require(tx.origin == account, "Not authorised!");
        return _storedValues[account];
    }

    function visibilityRules() external pure override returns (VisibilityConfig memory) {
        EventLogConfig[]  memory eventLogConfigs = new EventLogConfig[](2);

        // the signature of "event DataChanged(address indexed account, uint256 newValue);"
        bytes32 dataChangedEventSig = hex"0xec851d5c322f7f1dd5581f7432e9f6683a8709a4b1ca754ccb164742b82a7d2f";
        Field[]  memory relevantTo = new Field[](2);
        relevantTo[0] = Field.TOPIC1;
        relevantTo[1] = Field.SENDER;
        eventLogConfigs[0] = EventLogConfig(dataChangedEventSig, relevantTo);

        // the signature of "event MilestoneReached(uint256 noStoredValues);"
        bytes32 milestoneReachedEventSig = hex"0xd41033274424d56dd572e7196fb4230cf4141d546b91fc00555cab8403965924";
        Field[]  memory relevantTo = new Field[](1);
        relevantTo[0] = Field.EVERYONE;
        eventLogConfigs[1] = EventLogConfig(milestoneReachedEventSig, relevantTo);

        return VisibilityConfig(ContractCfg.PRIVATE, eventLogConfigs);
    }
}
```

#### Explanation[‚Äã](#explanation-4 "Direct link to Explanation")

The [`ContractTransparencyConfig`](https://github.com/ten-protocol/go-ten/blob/main/contracts/src/system/config/IContractTransparencyConfig.sol) interface is known by the TEN platform. When a contract is deployed, the platform will call the `visibilityRules` function, and store the `VisibilityConfig`.

For each event type, you can configure which fields can access it.

Notice how in the `visibilityRules` above, we configure the `DataChanged` event to be visible to the first field and the sender, and the `MilestoneReached` to be visible to everyone.

The other configuration: `VisibilityConfig.contractCfg` applies to the entire contract:

* `ContractCfg.TRANSPARENT`: The contracts will have public storage and events, behaving exactly like Ethereum.
* `ContractCfg.PRIVATE`: The default TEN behaviour, where the storage is not accessible and the events are individually configurable.


---

## Native commit-reveal

> Every on-chain game developer knows that moves that rely on entropy must be executed in two steps.

# Native commit-reveal

Every on-chain game developer knows that moves that rely on entropy must be executed in two steps.

Imagine you implement an on-chain coin flip game. The player pays 0.1ETH to choose `Heads` or `Tails`. If they win, they receive 0.2ETH, otherwise they lose the 0.1ETH. Even if randomness is unpredictable, this simple game can be exploited in several ways:

* The attacker can create a ‚Äúproxy‚Äù smart contract to play on their behalf. Using a similar mechanism to flash loans in DeFi: the proxy is programmed to make multiple actions and only ‚Äúcommit‚Äù if it can obtain a profit. In our case, if the coin flip is losing, the proxy can just revert. The only cost will be the gas burned.
* Transactions consume gas, and the gas cost can inadvertently reveal information. For instance, if a winning move is more computationally intensive than a losing one, players could deduce optimal moves by estimating gas costs for various actions.

The typical solution is to use an ad-hoc commit-reveal scheme. The smart contract ensures that the player commits to a move, and only afterwards reveals it to the chain. This way, the player can't change their mind after seeing the result.

This ad-hoc solution introduces extra complexity, latency and cost.

## The on-block-end callback[‚Äã](#the-on-block-end-callback "Direct link to The on-block-end callback")

The best solution is to decouple the move from the execution without increasing the latency or the cost. This way, the side-channel attacks are no longer possible because the move is not executed immediately. To avoid increasing the latency, the move must be executed in the same block as the "commit" transaction.

**The TEN platform provides a way to register a callback to be executed at the end of the current block.**

### How it works[‚Äã](#how-it-works "Direct link to How it works")

TEN provides a "System Contract" (a contract deployed and known by the platform.) You can get the address of the system contract for our testnet [here](https://sepolia.tenscan.io/resources/verified-data) - "Ten System Contract".

The interface for registering the callback is: [IPublicCallbacks](https://github.com/ten-protocol/go-ten/blob/main/contracts/src/system/interfaces/IPublicCallbacks.sol).

### Example[‚Äã](#example "Direct link to Example")

See below a secure implementation of the coin flip game using the callback:

```
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// this interface is known by the TEN system contract
interface IPublicCallbacks {
    function register(bytes calldata callback) external payable returns (uint256);
}

contract CoinFlip {
    // Event to emit the result of the coin flip
    event CoinFlipResult(address indexed player, bool didWin, uint256 randomNumber);

    private IPublicCallbacks tenCallbacks;
    mapping(uint256 callbackId => address player) public callbackToPlayer;
    mapping(address player => uint256 refundAmount) public playerToRefundAmount;

    modifier onlyTenSystemCall() { 
        require(msg.sender == address(tenCallbacks));
        _;
    }

    // you have to pass in the address of the system contract
    constructor(address _tenCallbacksAddress) {
        tenCallbacks = TenCallbacks(_tenCallbacksAddress);
    }

    // Function to initiate a coin flip. 
    // Notice how it doesn't execute the coin flip directly, but instead registers a callback.
    function flipCoin(bool isHeads) external payable {
        // Assume doFlipCoin costs 50_000 gas;
        // We deduct a predetermined amount from the bet to pay for delayed execution.
        uint256 etherGasForCoinFlip = 50_000*block.basefee;
        require(msg.value > etherGasForCoinFlip, "Insufficent gas");

        // Encode the function we want to be called by the TEN system contract.
        bytes memory callbackTargetInfo = abi.encodeWithSelector(this.doFlipCoin.selector, msg.sender, msg.value - etherGasForCoinFlip, isHeads);

        // Commit the move
        tenCallbacks.register{value: etherGasForCoinFlip}(callbackTargetInfo);
    }

    // Function to simulate a coin flip - notice that this must only be callable by the TEN system contract.
    // This function is called by the TEN platform as a synthetic transaction in the same block as the user transaction.
    function doFlipCoin(address bettor, uint256 stake, bool wantsHeads) external onlyTenSystemCall {
        // Assume getRandomNumber() is a function that returns a random number
        uint256 randomNumber = getRandomNumber();

        // Simulate a coin flip: 0 for tails, 1 for heads
        bool isHeads = (randomNumber % 2) == 1;

        if (wantsHeads == isHeads) {
            //pay out to winner
            (bool success, ) = payable(bettor).call{value: stake*2}("");
            require(success, "Payment failed.");
        }
        // Emit the result of the coin flip
        emit CoinFlipResult(msg.sender, isHeads, randomNumber);
    }

    function getRandomNumber() internal view returns (uint256) {
        // see native entropy
    }

}
```

Notice how we split the logic in two. The first part is the "commit" part, which is executed by the user. The second part is the "reveal" part, which is executed only by the TEN platform.

*Note that you have to enforce the second function to be called only by the TEN system contract.*


---

## Native secure entropy

> This excellent blog explains the need for native entropy.

# Native secure entropy

This excellent [blog](https://medium.com/obscuro-labs/against-all-odds-securing-randomness-on-the-blockchain-4c15587a39a8) explains the need for native entropy.

## How it works[‚Äã](#how-it-works "Direct link to How it works")

TEN provides a "System Contract" (a contract deployed and known by the platform.) You can get the address of the system contract for our testnet [here](https://sepolia.tenscan.io/resources/verified-data) - "??".

The interface you must implement is:

```
interface IRnd {
    function getRandomNumber() external returns (uint256);
}
```

## Example[‚Äã](#example "Direct link to Example")

```

// TEN provides a system contract that provides a unique secure random number generator.
interface IRnd {
    function getRandomNumber() external returns (uint256);
}

contract CoinFlip {
    private IRnd rnd;

    // you have to pass in the address of the system contract
    constructor(address _rndSystemAddress) {
        rnd = IRnd(_rndSystemAddress);
    }

    function getRandomNumber() internal view returns (uint256) {
        return rnd.getRandomNumber();
    }
}
```


---

## Precise transaction timestamp

> Real-time games require users to make quick decisions, and the outcomes depend on the precise moment in time when the action was made.

# Precise transaction timestamp

Real-time games require users to make quick decisions, and the outcomes depend on the precise moment in time when the action was made. This doesn't work well on-chain because latencies are not low enough.

### Option 1 - External Timestamp oracle[‚Äã](#option-1---external-timestamp-oracle "Direct link to Option 1 - External Timestamp oracle")

A standard Ethereum smart contract does not have access to the timestamp of a transaction. The reason is that the "clock" of the user is not trusted, and a network like "Ethereum" is decentralised and there is no trusted "clock".

A dApp wanting to timestamp a transaction would have to use a trusted "Oracle" to sign over a payload containing the tx hash and the timestamp. And then create another Ethereum transaction with this payload, and the smart contract matching the previous action with this proof. This approach is very complex with multiple on-chain transactions and adds even more latency.

### TEN - Native timestamp oracle[‚Äã](#ten---native-timestamp-oracle "Direct link to TEN - Native timestamp oracle")

The TEN protocol provides a native timestamp oracle, and a system smart contract which exposes this information to smart contracts.

The trusted authority is the "Sequencer" node which is running in a Trusted Execution Environment (TEE).

Each transaction is accompanied by the precise timestamp when included in a block.

## How it works[‚Äã](#how-it-works "Direct link to How it works")

TEN provides a "System Contract" (a contract deployed and known by the platform.) You can get the address of the system contract for our testnet [here](https://sepolia.tenscan.io/resources/verified-data) - under `TenSystemCalls`.

The interface you must implement is:

```
interface ITimestamp {
    function getTransactionTimestamp() external returns (uint256);
}
```

## Example[‚Äã](#example "Direct link to Example")

```

// TEN provides a system contract that returns the precise timestamp of the calling transaction
interface ITimestamp {
    function getTransactionTimestamp() external returns (uint256);
}

contract CoinFlip {
    private ITimestamp timestamp;

    // you have to pass in the address of the system contract
    constructor(address _timestampSystemAddress) {
        timestamp = ITimestamp(_timestampSystemAddress);
    }

    function getRandomNumber() internal view returns (uint256) {
        return rnd.getRandomNumber();
    }
}
```


---

## Cross-Chain Bridging

> The TEN Bridge project aims to facilitate the seamless transfer of assets between the Ethereum blockchain and the TEN blockchain. This documentation provides an overview of the project, its purpose, supported tokens, and usage instructions.

# Cross-Chain Bridging

The TEN Bridge project aims to facilitate the seamless transfer of assets between the Ethereum blockchain and the TEN blockchain. This documentation provides an overview of the project, its purpose, supported tokens, and usage instructions.

## Purpose[‚Äã](#purpose "Direct link to Purpose")

The primary goal of the TEN Bridge is to enable users to move assets between Ethereum and TEN efficiently and securely. This bridge will serve as a vital infrastructure component for users who wish to interact with assets on both blockchains. (Link TBC)

## Supported Tokens[‚Äã](#supported-tokens "Direct link to Supported Tokens")

To provide flexibility and utility to users, the TEN Bridge supports the following tokens:

* Ethereum (ETH)
* TEN token (TEN)
* Tether (USDT)
* USD Coin (USDC)

## Usage[‚Äã](#usage "Direct link to Usage")

### Prerequisites[‚Äã](#prerequisites "Direct link to Prerequisites")

Before using the TEN Bridge, ensure you have the following:

* MetaMask or any Ethereum-compatible wallet

### Steps to Transfer Assets[‚Äã](#steps-to-transfer-assets "Direct link to Steps to Transfer Assets")

1. Connect your Ethereum wallet (e.g., MetaMask) to the TEN Bridge interface.
2. Select the asset you wish to transfer and specify the destination blockchain (Ethereum or TEN).
3. Enter the amount of the asset you want to transfer.
4. Review the transaction details and confirm the transfer.
5. Once confirmed, wait for the transaction to be processed. The transfer may take some time depending on network congestion.
6. Once the transfer is complete, you will receive a confirmation notification.

### Notes[‚Äã](#notes "Direct link to Notes")

* Please ensure you have sufficient gas fees (for Ethereum transactions) and TEN network fees to cover the transaction costs.
* Transactions may take varying amounts of time to process depending on network congestion and other factors.
* Always double-check the recipient address before confirming the transfer to avoid any potential loss of assets.

## Support[‚Äã](#support "Direct link to Support")

For any enquiries or assistance regarding the TEN Bridge, please contact our team at <team@obscu.ro>.

## Conclusion[‚Äã](#conclusion "Direct link to Conclusion")

The TEN Bridge provides a convenient and secure way for users to transfer assets between Ethereum and TEN blockchains. By supporting multiple tokens, including ETH, TEN, USDT and USDC, the bridge enhances interoperability and accessibility for users within the ecosystem.


---

## High Level Concepts

> Below are the core concepts that make TEN unique while maintaining complete compatibility with existing Ethereum tooling and workflows.

# High Level Concepts

Below are the core concepts that make TEN unique while maintaining complete compatibility with existing Ethereum tooling and workflows.

## End-to-End Encryption[‚Äã](#end-to-end-encryption "Direct link to End-to-End Encryption")

All contract execution runs inside TEEs; inputs, state, and (optionally) logs can be private. See the [Overview](/docs/overview.md) for architecture and threat model.

Clients establish HTTPS connections that terminate inside TEEs via the TEN Gateway, preventing plaintext exposure on intermediaries; smart contracts then execute entirely within the enclave boundary, and contract state plus sensitive metadata are stored encrypted at rest, with read access enforced through Viewing Keys and policy logic.

## Smart Contract Execution with Hidden State[‚Äã](#smart-contract-execution-with-hidden-state "Direct link to Smart Contract Execution with Hidden State")

TEN disables `getStorageAt` by default and ensures private variables are truly private, only accessible through authorised functions that developers define.

Revisit [Data Acess](/docs/smart-contract-features/data-access.md) for more information.

## Data Access Control Primitives[‚Äã](#data-access-control-primitives "Direct link to Data Access Control Primitives")

TEN introduces **[Smart Transparency](https://medium.com/obscuro-labs/web3-needs-access-control-9a80719eec4a)** ‚Äî a paradigm where smart contracts enforce rules of data access, not just computation. This provides fine-grained control over who can see what data and when, including programmable disclosure, conditional data access, and event visibility rules.

## TEN Gateway[‚Äã](#ten-gateway "Direct link to TEN Gateway")

Web service running in TEEs that provides the secure edge for dApps and user wallets:

* Routes encrypted transactions between clients and validator/sequencer nodes
* Manages Viewing Keys on behalf of users for authenticated private view calls
* Manages Session Keys to enable no-click UX under developer-defined policies
* Caches encrypted metadata and frequently accessed data for performance and availability

See [TEN Gateway](/docs/write-ten-dapp/testnet.md#ten-gateway) for more information.

## Personal Data[‚Äã](#personal-data "Direct link to Personal Data")

TEN enables true **personal data** management on-chain by ensuring that sensitive user information remains encrypted and accessible only to authorised parties. This supports applications like private messaging, confidential medical records, and identity verification systems while maintaining compliance with data protection regulations.

## Free Native On-Chain Randomness[‚Äã](#free-native-on-chain-randomness "Direct link to Free Native On-Chain Randomness")

Secure, immediate, and free randomness via enclave-backed `block.prevrandao` ‚Äî no oracles needed.

```
function getRandomNumber() public view returns (uint256) {
    return uint256(block.prevrandao);  // Secure randomness on TEN
}
```

## Precise Timestamping of Transactions[‚Äã](#precise-timestamping-of-transactions "Direct link to Precise Timestamping of Transactions")

Every transaction on TEN receives a **precise timestamp** when it reaches the sequencer, enabling applications that require exact timing information such as real-time games, auction systems, and time-sensitive financial instruments.

An example of how this works can be found in the [TEN Aviator](https://github.com/ten-protocol/ten-aviator/tree/1aa6454da5c52586eaccc9cf3d957b9c5d5f2f6d) game that utilises real-time game state tracking.

```
function checkGameEnd() external onlyOwner {
        if (block.timestamp >= gameStartTime + gameDuration) {
            endGame();
        }
    }
```

## Native Commit-Reveal (Required by Many Games)[‚Äã](#native-commit-reveal-required-by-many-games "Direct link to Native Commit-Reveal (Required by Many Games)")

TEN eliminates the need for traditional commit-reveal schemes through its **native async execution** and **on-block-end callbacks**. This provides the same security benefits without the complexity, latency, and cost of separate commit and reveal transactions, enabling seamless gaming experiences.

TEN provides secure entropy that is generated within the TEE environment using hardware-based random number generation, ensuring that random values cannot be predicted or manipulated by node operators or external parties.

```
function _resetSecretNumber() private {
   uint256 randomNumber = block.prevrandao;
   secretNumber = (randomNumber % MAX_GUESS) + 1;
}
```

On Ethereum mainnet, `block.prevrandao` must be used with care. It has some important caveats:

* The same random value is provided to every transaction executing in the same block.
* The value is known at the time the transactions are being ordered into the block, meaning MEV bots can manipulate outcomes.

The same code on TEN does not expose those attack vectors. It should be noted that:

* A fresh, uncorrelated key is generated for each transaction.
* The value cannot be seen outside of the executing code, secure enclave hardware means even node operators can't access it.
* Outcomes cannot be known until the block is published (which cannot be undone), removing the threat of MEV exploits.

See [Secure Entropy](/docs/smart-contract-features/native-entropy.md) for more information.

## Native Session Keys[‚Äã](#native-session-keys "Direct link to Native Session Keys")

TEN provides **native session key** support managed by TEEs, eliminating the need for proxy contracts while enabling seamless user experiences. Users can play games or interact with dApps without signing every transaction, while developers benefit from simple integration through standard RPC endpoints.

The management of these session keys is provided by the [ten-kit](https://github.com/ten-protocol/ten-kit/tree/2c4265bdb2832249af8c9ec21c4b60d02eb8dd3a?tab=readme-ov-file#advanced-example-with-session-keys) library, which provides the React components and hooks needed, as well as wallet connection and privacy‚Äëpreserving transactions.

See [Session Keys](/docs/write-ten-dapp/session-keys.md) for more information.

***


---

## Network Configuration

> Migrating to TEN enables your dApp to leverage ‚Äúprogrammable encryption.‚Äù Below are steps to help you transition smoothly.

# Network Configuration

Migrating to TEN enables your dApp to leverage ‚Äúprogrammable encryption.‚Äù Below are steps to help you transition smoothly.

### Key Migration Steps[‚Äã](#key-migration-steps "Direct link to Key Migration Steps")

* Update your Hardhat deployment to support the `--network ten` option.
* Add data protection logic to your view functions (if applicable).
* Configure visibility rules for event logs and internal storage.
* Add the TEN onboarding widget to your JavaScript UI.
* Add features that make use of secure, verifiable randomness using `block.prevrandao` or precise timestamping

## 1. Configuring Hardhat[‚Äã](#1-configuring-hardhat "Direct link to 1. Configuring Hardhat")

First, set up a Hardhat project if you haven't already.

### 1.1 Installing the TEN Hardhat Plugin[‚Äã](#11-installing-the-ten-hardhat-plugin "Direct link to 1.1 Installing the TEN Hardhat Plugin")

To add TEN Network compatibility, install the `ten-hardhat-plugin`:

```
npm install ten-hardhat-plugin
```

*You can use `npm` or `yarn` to install plugins.*

### 1.2 Configuring `hardhat.config.js`[‚Äã](#12-configuring-hardhatconfigjs "Direct link to 12-configuring-hardhatconfigjs")

Modify `hardhat.config.js` in your project‚Äôs root directory as follows:

```
import { HardhatUserConfig } from "hardhat/config";
import "@nomiclabs/hardhat-waffle";
import "ten-hardhat-plugin";

module.exports = {
  solidity: "0.8.10",
  networks: {
    hardhat: {
    // Configuration for the Hardhat Network
    },
    ten: {
        url: "https://testnet.ten.xyz/v1/",
        chainId: 8443,
        accounts: ["your-private-key"],
    },
  },
};

export default config;
```

Once configured, you can start writing or migrating your smart contracts.


---

## Sample dApps

> Below you can view our in-house sample dApps developed to harness the power of TEN.

# Sample dApps

Below you can view our in-house sample dApps developed to harness the power of TEN.

## Battleships[‚Äã](#battleships "Direct link to Battleships")

On-chain game heavily inspired by the classic board game Battleships. Players are presented with a grid and select squares to try to sink as many of the ships as possible. Each successful hit or ship sinking is rewarded with a ZEN game token.

![TEN Battleships](/assets/images/battleships-4940a8d50128cc24b2938319ebe34c47.png)

View the repository for Battleships [here](https://github.com/ten-protocol/battleships-campaign/).

## Crash Game[‚Äã](#crash-game "Direct link to Crash Game")

A high-stakes betting game where players wager tokens on a rocket's flight trajectory. The rocket's multiplier increases over time, but crashes at an unpredictable moment. Players must cash out before the crash to win their bet multiplied by the current value, or lose everything if they're too greedy.

![TEN Aviator](/assets/images/crash-fc22a5423d0b2a316ddca4ffe30f97c6.png)

View the repository for the TEN Crash game [here](https://github.com/ten-protocol/ten-aviator).

## Trickly[‚Äã](#trickly "Direct link to Trickly")

An on-chain game where the contract holds a private, incrementing number. Each time a player plays, the number is incremented and returned to them. If the number ends in a zero, the player earns a reward in ZEN tokens. The more trailing zeros the number has, the greater the reward.

![Trickly](/assets/images/trickly-1219b489ce72b59ec130631cf9e49d2c.png)

View the repository for Trickly [here](https://github.com/ten-protocol/trickly/).


---

## Account Abstraction

> The key feature of Account Abstraction (EIP-4337) is ‚Äúsession keys‚Äù (SKs) through a proxy smart contract.

# Account Abstraction

The key feature of [Account Abstraction](https://medium.com/p/2e85bde4c54d) (EIP-4337) is ‚Äúsession keys‚Äù (SKs) through a proxy smart contract. SKs allow users to interact with the blockchain without signing every transaction, which is a major UX improvement.

TEN supports "native" SKs - these are managed by the platform and do not require a proxy contract.

In TEN, SKs are managed by dApp developers through dedicated RPC endpoints.

## Solution overview[‚Äã](#solution-overview "Direct link to Solution overview")

Imagine you're developing an on-chain game, and you want a smooth UX without the distraction of signing every move.

Conceptually, the game will create a session key (SK) for the user, then ask the user to move some funds to that address, and then create ‚Äúmove‚Äù transactions signed with the SK.

If the game were to create the SK in the browser, there would be a risk of the user losing the SK, and the funds associated with it, in case of an accidental exit. With TEN, the dApp developer doesn't have to worry about this, because the SKs are managed by TEEs.

## Usage[‚Äã](#usage "Direct link to Usage")

The steps below describe the implementation for a game developer‚Äîthe primary use case for SKs. Note that SKs can be used for any dApp that requires a no‚Äëclick UX.

### When the game starts[‚Äã](#when-the-game-starts "Direct link to When the game starts")

Before the user can start playing, the game must create the SK and ask the user to move some funds to that address. The funds will be used to pay for moves.

* Call the RPC `eth_getStorageAt` with address `0x0000000000000000000000000000000000000003` - this will return the hex-encoded address of the SK. The dApp needs to store this address for future use.
* Create a normal transaction that transfers some ETH to the SK. The amount depends on how many "moves" the user is prepared to prepay for.
* Ask the user to sign this transaction with their standard wallet, and submit it to the network using the library of your choice.
* The session key is automatically activated and ready to use.

### During the game[‚Äã](#during-the-game "Direct link to During the game")

After sending funds to the SK, create a transaction for each move, but don't ask the user to sign them. Instead, submit them to the network unsigned using the RPC `eth_getStorageAt` with address `0x0000000000000000000000000000000000000005` and the following parameters:

```
{
  "sessionKeyAddress": "0x...", // The session key address
  "tx": "base64_encoded_transaction" // The unsigned transaction encoded as base64
}
```

The platform will sign the transactions on behalf of the user.

As a game developer, you are responsible for keeping track of the SK‚Äôs balance. You can also query the network for the balance of the SK address. If the SK runs out of balance, you must ask the user to move more funds to the SK.

### Managing session keys[‚Äã](#managing-session-keys "Direct link to Managing session keys")

TEN provides additional RPC endpoints for managing session keys:

* `eth_getStorageAt` with address `0x0000000000000000000000000000000000000004` ‚Äî permanently removes the session key. This requires the following parameters:

```
{
  "sessionKeyAddress": "0x..." // The session key address to delete
}
```

### Finishing the game[‚Äã](#finishing-the-game "Direct link to Finishing the game")

When a game ends, you must move the remaining funds back to the main address.

* Create a transaction (tx) that moves the funds back from the SK to the main address. Submit it unsigned, because the funds are controlled by the SK.

## Example implementation[‚Äã](#example-implementation "Direct link to Example implementation")

Here's a complete example of how to implement session keys in a JavaScript dApp:

```
// 1. Create a session key
async function createSessionKey() {
  const response = await fetch("https://testnet.ten.xyz/v1/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "eth_getStorageAt",
      params: ["0x0000000000000000000000000000000000000003", "0x0", "latest"],
      id: 1,
    }),
  });

  const data = await response.json();
  return data.result; // Returns the session key address
}

// 2. Fund the session key (user signs this transaction)
async function fundSessionKey(sessionKeyAddress, amount) {
  // This would be a normal transaction signed by the user's wallet
  // transferring ETH to the session key address
}

// 3. Send unsigned transactions using the session key
async function sendUnsignedTransaction(sessionKeyAddress, unsignedTx) {
  const txBase64 = btoa(JSON.stringify(unsignedTx)); // Convert to base64

  const response = await fetch("https://testnet.ten.xyz/v1/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "eth_getStorageAt",
      params: [
        "0x0000000000000000000000000000000000000005",
        JSON.stringify({
          sessionKeyAddress: sessionKeyAddress,
          tx: txBase64,
        }),
        "latest",
      ],
      id: 1,
    }),
  });

  const data = await response.json();
  return data.result; // Returns the transaction hash
}

// 4. Delete the session key when done
async function deleteSessionKey(sessionKeyAddress) {
  const response = await fetch("https://testnet.ten.xyz/v1/", {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({
      jsonrpc: "2.0",
      method: "eth_getStorageAt",
      params: [
        "0x0000000000000000000000000000000000000004",
        JSON.stringify({
          sessionKeyAddress: sessionKeyAddress,
        }),
        "latest",
      ],
      id: 1,
    }),
  });

  const data = await response.json();
  return data.result; // Returns 0x01 for success, 0x00 for failure
}
```


---

## Set Up Development Environment

> 1. Wallet Setup & Configuration

# Set Up Development Environment

## 1. Wallet Setup & Configuration[‚Äã](#1-wallet-setup--configuration "Direct link to 1. Wallet Setup & Configuration")

To start building on TEN, you first need to set up and configure your wallet with the TEN network.

1. **Install MetaMask**: [Install](https://metamask.io/download/) MetaMask either as a browser extension or mobile app.

2. **Configure MetaMask for TEN**:

   <!-- -->

   * Visit the [TEN Gateway](https://gateway.ten.xyz/) for wallet setup.
   * Click on ‚ÄúConnect to TEN Testnet‚Äù and follow the on-screen instructions.
   * Learn more about the [TEN Gateway](/docs/write-ten-dapp/high-level-concepts.md#ten-gateway).

3. **Acquire Testnet ETH Tokens**: To perform transactions, you'll need testnet ETH tokens. Refer to our [Getting tokens](/docs/write-ten-dapp/testnet.md#requesting-testnet-eth).

### Supported Wallets[‚Äã](#supported-wallets "Direct link to Supported Wallets")

These wallets are confirmed to work smoothly with the TEN Gateway:

* MetaMask
* Rabby Wallet

## 2. Setting Up the Environment[‚Äã](#2-setting-up-the-environment "Direct link to 2. Setting Up the Environment")

Once your wallet is ready, you can proceed with the development and deployment of your smart contracts.

1. **Choose an IDE**: Use your preferred development environment or Integrated Development Environment (IDE) like Truffle, Remix, Hardhat, or Foundry.
2. **Connect IDE to MetaMask**: Ensure your chosen IDE is connected to your MetaMask wallet.

## 3. Docker Configuration[‚Äã](#3-docker-configuration "Direct link to 3. Docker Configuration")

For developers running a node and infrastructure using Docker on a Mac, please be aware that you must **disable** the ‚ÄúUse Rosetta for x86\_64/amd64 emulation on Apple Silicon‚Äù setting. Failing to do so will prevent the testnet from running correctly.


---

## Testnet

> TEN Sepolia is our testnet that replicates the capabilities of the TEN Mainnet network. Linked to the Sepolia testnet, you can authenticate with the testnet TEN gateway, use the TEN faucet, and develop and deploy dApps for testing.

# Testnet

TEN Sepolia is our testnet that replicates the capabilities of the TEN Mainnet network. Linked to the Sepolia testnet, you can authenticate with the testnet TEN gateway, use the TEN faucet, and develop and deploy dApps for testing.

## TEN Gateway[‚Äã](#ten-gateway "Direct link to TEN Gateway")

![TEN Hosted Gateway](/assets/images/gateway-ffd3a1c37b87ae0d7df3111844fe94af.png)

Visit the TEN testnet gateway [here](https://testnet.ten.xyz/). Follow the on‚Äëscreen instructions to authenticate with the hosted gateway that allows you to interact with the testnet.

## TEN Sepolia Faucet[‚Äã](#ten-sepolia-faucet "Direct link to TEN Sepolia Faucet")

![TEN Discord Faucet](/assets/images/faucet.ten.xyz-b867b87d2e217d4c67df393bb160c172.jpg)

Using the steps provided, you can request testnet ETH from the faucet available on the TEN Gas Station.

## **Requesting Testnet ETH**[‚Äã](#requesting-testnet-eth "Direct link to requesting-testnet-eth")

1. Make a note of your EVM wallet address or copy it to your clipboard.
2. Head over to [TEN Gas Station](https://testnet-faucet.ten.xyz/).
3. Paste your EVM wallet address into the wallet address field.
4. Log in with your Discord and X (Twitter) accounts.
5. Then, complete the available tasks.

## TENscan[‚Äã](#tenscan "Direct link to TENscan")

You can use the TEN block explorer to view transaction data occurring on the testnet [here](https://testnet.tenscan.io/).


---

## Tutorial

> You can follow this tutorial on GitHub that demonstrates how TEN‚Äôs precise timestamping enables sophisticated financial applications requiring exact timing. The combination of privacy, accurate timestamps, and Ethereum compatibility makes TEN ideal for high frequency trading and other time‚Äësensitive financial applications.

# Tutorial

You can follow [this](https://github.com/ten-protocol/hft-tutorial/blob/main/README.md) tutorial on GitHub that demonstrates how TEN‚Äôs precise timestamping enables sophisticated financial applications requiring exact timing. The combination of privacy, accurate timestamps, and Ethereum compatibility makes TEN ideal for high frequency trading and other time‚Äësensitive financial applications.

You can either follow the steps in the `README` to build it from scratch or clone the repo and run the existing code.


---

