# Hosted Gateway

The TEN Gateway is a critical application that facilitates communication between a TEN node and various tools that require a connection to it, such as MetaMask. Due to the encryption of data within a TEN node, direct communication is not feasible.

The program conforms to the Ethereum JSON-RPC specification ([Ethereum JSON-RPC Specification](https://playground.open-rpc.org/?schemaUrl=https://raw.githubusercontent.com/ethereum/eth1.0-apis/assembled-spec/openrpc.json)) and also supports additional APIs to ensure compatibility with popular tools like MetaMask.

You have the flexibility to host the TEN Gateway yourself or use one of the hosted gateways if you choose to join TEN. You also have the option to run and use the program independently. The diagram below illustrates different usage scenarios, with Bob and Charlie using the hosted version and Alice managing it independently.

## Workflow[​](#workflow "Direct link to Workflow")

The onboarding process is straightforward and requires only a few clicks:

1. The user navigates to a website where a hosted TEN Gateway is running and clicks on "Join TEN." This action will add a network to their wallet.
2. The user then connects their wallet and switches to the TEN network, if they have not done so already.
3. In the wallet popup, the user is prompted to sign over an EIP-712 formatted message or text message which includes an encryption token.

## Endpoints[​](#endpoints "Direct link to Endpoints")

### GET /join[​](#get-join "Direct link to GET /join")

This endpoint generates a key-pair, saves it in the database, derives an encryption token from the keys, and returns the encryption token.

### GET /getmessage[​](#get-getmessage "Direct link to GET /getmessage")

This endpoint generates a message for the user to sign in order to authenticate their address. We currently support EIP712 messages and simple text messages that need to be signed with Personal sign by the user.

Here is an example for the GET request body:

```
{
    "encryptionToken": "2d127471df48dad460a60194496f975fd9d558d1",
    "formats": ["EIP712", "Personal"]
}
```

* `encryptionToken` is mandatory and is the encryption token generated by the /join endpoint.

* `formats` is optional and can be either "EIP712" or "Personal". If not provided / or both are provided, the default value is "EIP712".

Message returned by the endpoint is in the following format:

```
{
    "message": "<message>",
    "type": "<EIP712/Personal>"
}
```

EIP712 Message uses following format:

```
{
    types: {
      EIP712Domain: [
        { name: "name", type: "string" },
        { name: "version", type: "string" },
        { name: "chainId", type: "uint256" },
      ],
      Authentication: [
        { name: "Encryption Token", type: "address" },
      ],
    },
    primaryType: "Authentication",
    domain: {
      name: "Ten",
      version: "1.0",
      chainId: <TenChainID>,
    },
    message: {
      "Encryption Token": <encryptionToken>
    },
}
```

And Personal Message uses following format:

```
Token: %s on chain: %d version: %d
```

### POST /authenticate?token=$EncryptionToken[​](#post-authenticatetokenencryptiontoken "Direct link to POST /authenticate?token=$EncryptionToken")

This endpoint enables the addition of multiple addresses for each encryption token. Prior to saving, it performs several checks on the signature and encryption token.

Here's an example of the POST request body for the /authenticate endpoint:

```
{
    "address": "0xEF1C76228AeaDE07B74eA4a749d02f539cCff16a",
    "signature": "0x781699d25d62ebaa3cc0901ac1fd9fda4e7e3b143bee854b262434e3e22021d1607b5680924ac439dec9838344d6785100c7043312cec07b7fd1e9d26983f69f1b",
    "type": "EIP712"
}
```

* `address` is mandatory and is the address of the user who is trying to authenticate
* `signature` is mandatory and is the signature of the message generated by the /getmessage endpoint
* `type` is optional and can be either "EIP712" or "Personal". If not provided, the default value is "EIP712".

### GET /query/address?token=$EncryptionToken\&a=$Address[​](#get-queryaddresstokenencryptiontokenaaddress "Direct link to GET /query/address?token=$EncryptionToken\&a=$Address")

This endpoint returns a boolean value (true or false) based on whether the given address is registered with the provided encryption token.

### GET /revoke?token=$EncryptionToken[​](#get-revoketokenencryptiontoken "Direct link to GET /revoke?token=$EncryptionToken")

This endpoint facilitates the removal of a certain encryption token's access by deleting the key-pair from the database. This is particularly useful when a user wishes to revoke access for a specific encryption token.
